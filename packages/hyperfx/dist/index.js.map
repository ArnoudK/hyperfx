{"version":3,"sources":["../src/index.ts","../src/elem/elem.ts","../src/pages/navigate.ts","../src/elem/text.ts","../src/elem/headings.ts","../src/elem/style.ts","../src/elem/img.ts","../src/elem/input.ts","../src/elem/head.ts","../src/elem/semantic.ts","../src/reactive/morphing.ts","../src/reactive/component.ts","../src/reactive/event.ts","../src/pages/register.ts","../src/fetcher.ts"],"sourcesContent":["import { RenderToBody, Div, t } from \"./elem/elem\";\nimport { P, Span, A, Abbr, B, Bdi, Bdo, Cite, I } from \"./elem/text\";\nimport { H1, H2, H3, H4, H5, H6 } from \"./elem/headings\";\nimport { Hr, Br } from \"./elem/style\";\nimport { Img } from \"./elem/img\";\nimport { Input, Label } from \"./elem/input\";\n\nimport { Title } from \"./elem/head\";\n\nimport {\n  Article,\n  Address,\n  Aside,\n  Button,\n  Nav,\n  Main,\n  Footer,\n} from \"./elem/semantic\";\n\nimport { Component, RootComponent, PageComponent } from \"./reactive/component\";\n\nimport { WithEventListener } from \"./reactive/event\";\n\nimport { navigateTo } from \"./pages/navigate\";\n\nimport { RouteRegister, GetParamValue } from \"./pages/register\";\n\nimport { fetcher } from \"./fetcher\";\n\n/* Extension methods */\n\nObject.defineProperty(HTMLElement.prototype, \"WithEventListener$HFX\", {\n  value: function <T extends HTMLElement, K extends keyof HTMLElementEventMap>(\n    this: T,\n    eventtype: K,\n    listener: (ev: HTMLElementEventMap[keyof HTMLElementEventMap]) => void\n  ) {\n    this.addEventListener(eventtype, listener);\n    return this;\n  },\n});\n\nObject.defineProperty(HTMLElement.prototype, \"Modify$HFX\", {\n  value: function <T extends HTMLElement>(this: T, modfn: (a: T) => void) {\n    modfn(this);\n    return this;\n  },\n});\n\ndeclare global {\n  interface HTMLElement {\n    /** Add an event listener and return the Element */\n    WithEventListener$HFX<K extends keyof HTMLElementEventMap>(\n      eventtype: K,\n      listener: (ev: HTMLElementEventMap[keyof HTMLElementEventMap]) => void\n    ): this;\n    /** Run a function on the Element and return the Element */\n    Modify$HFX<T extends HTMLElement>(this: T, modfn: (el: T) => void): this;\n  }\n}\n\nexport {\n  /* HTML Tags */\n  A,\n  Abbr,\n  Address,\n  Article,\n  Aside,\n  B,\n  Bdi,\n  Bdo,\n  Button,\n  Br,\n  Cite,\n  Div,\n  Footer,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n  H6,\n  Hr,\n  I,\n  Img,\n  Input,\n  Label,\n  Main,\n  Nav,\n  P,\n  t,\n  Span,\n  \n  /* Other DOM stuff */\n  RenderToBody,\n  \n  Title,\n  /* Reactive stuff */\n  WithEventListener,\n\n  /* Components */\n  Component,\n  RootComponent,\n  PageComponent,\n\n  /* Routing */\n  navigateTo,\n  RouteRegister,\n  GetParamValue,\n  /* fetcher */\n  fetcher,\n};\n","import type { GlobalAttr, HtmlAtrribute } from \"./attr\";\n\ntype BodyChild = HTMLDivElement | HTMLSpanElement | HTMLParagraphElement;\n\nexport function Div(attributes: GlobalAttr, ...children: BodyChild[]) {\n  const res = document.createElement(\"div\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n\n/** Render text (the text content inside a tag): */\nexport const t = (t: string) => document.createTextNode(t);\n\nexport const RenderToBody = (el: HTMLElement) => document.body.appendChild(el);\n","/**\n * Navigate to a url by pushing it and popstate this allows for soft navigation using HyperFX\n * The URL must be registered in the PageRegister!!!\n */\nexport function navigateTo(href: string) {\n  history.pushState({}, \"\", href);\n  window.dispatchEvent(new Event(\"popstate\"));\n}\n","import { navigateTo } from \"../pages/navigate\";\nimport type { GlobalAttr, targetValues } from \"./attr\";\nimport { t } from \"./elem\";\n/** \n    * this file is for Elements with phrasing content that should have text as children\n    * Phrasing context:  https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#phrasing_content\n    But only the ones that are not just semantic divs\n    */\n\nexport function Span(attributes: GlobalAttr, text: string) {\n  const res = document.createElement(\"span\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  res.appendChild(t(text));\n  return res;\n}\ntype TextChild = Text | HTMLElement;\n\nexport function P(attributes: GlobalAttr, ...children: TextChild[]) {\n  const res = document.createElement(\"p\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport function Abbr(attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(\"abbr\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\ntype anchorAttr = Partial<GlobalAttr> & {\n  href: string;\n  target?: targetValues;\n  download?: \"download\";\n  filename?: string;\n  hreflang?: string;\n  ping?: string;\n  referrerpolicy?:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  rel?: string;\n};\n\nexport function A(attributes: anchorAttr, ...children: TextChild[]) {\n  const res = document.createElement(\"a\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  if (attributes.href[0] == \"/\") {\n    res.addEventListener(\"click\", (ev) => {\n      navigateTo((ev.target as HTMLAnchorElement).href);\n      ev.preventDefault();\n      return false;\n    });\n  }\n  return res;\n}\n\nexport function B(attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(\"b\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport function Bdi(attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(\"bdi\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport function Bdo(attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(\"bdo\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport function I(attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(\"bdo\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport function Cite(attributes: GlobalAttr, ...children: TextChild[]) {\n  const res = document.createElement(\"bdo\");\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n","import type { GlobalAttr } from \"./attr\";\n\ntype heads = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n\nfunction Head(t: heads, attributes: GlobalAttr, ...children: Text[]) {\n  const res = document.createElement(t);\n  const attrs = Object.keys(attributes);\n\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n  for (const child of children) {\n    res.appendChild(child);\n  }\n  return res;\n}\n\nexport const H1 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h1\", attributes, ...children);\n\nexport const H2 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h2\", attributes, ...children);\n\nexport const H3 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h3\", attributes, ...children);\n\nexport const H4 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h4\", attributes, ...children);\n\nexport const H5 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h5\", attributes, ...children);\n\nexport const H6 = (attributes: GlobalAttr, ...children: Text[]) =>\n  Head(\"h6\", attributes, ...children);\n","import type { GlobalAttr } from \"./attr\";\n\nexport function Br(attributes: GlobalAttr) {\n  const res = document.createElement(\"br\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  return res;\n}\nexport function Hr(attributes: GlobalAttr) {\n  const res = document.createElement(\"hr\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  return res;\n}\n","import type { GlobalAttr } from \"./attr\";\n\ntype requiredImgAttr = { src: string };\ntype optionImgAttr = {\n  alt: string;\n  attributionsrc: string;\n  crossorigin: \"anonymous\" | \"use-credentials\";\n  decoding: \"sync\" | \"async\" | \"auto\";\n  elementtiming: string;\n  fetchpriority: \"high\" | \"low\" | \"auto\";\n  height: string;\n  width: string;\n  loading: \"eager\" | \"lazy\";\n  referrerpolicy:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  sizes: string;\n  srcset: string;\n};\n\ntype imageAttr = requiredImgAttr & GlobalAttr & Partial<optionImgAttr>;\n\nexport function Img(attrs: imageAttr) {\n  const img = document.createElement(\"img\");\n  const attributes = Object.keys(attrs);\n  for (const attr of attributes) {\n    img.setAttribute(attr, attrs[attr! as any as keyof imageAttr]!);\n  }\n  return img;\n}\n","import type { GlobalAttr, targetValues } from \"./attr\";\n\ntype inputRequired = {\n  type:\n    | \"button\"\n    | \"checkbox\"\n    | \"color\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"email\"\n    | \"file\"\n    | \"hidden\"\n    | \"image\"\n    | \"month\"\n    | \"password\"\n    | \"radio\"\n    | \"range\"\n    | \"reset\"\n    | \"search\"\n    | \"submit\"\n    | \"tel\"\n    | \"text\"\n    | \"time\"\n    | \"url\"\n    | \"week\";\n  /**   @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#name\n        '_charset_' combined with hidden will set the value to the 'user-agent'  \n        'isindex' is not allowed as name\n         */\n  name: string | \"_charset_\";\n  id: string;\n};\n\nconst inputTypes = [\n  \"button\",\n  \"checkbox\",\n  \"color\",\n  \"date\",\n  \"datetime-local\",\n  \"email\",\n  \"file\",\n  \"hidden\",\n  \"image\",\n  \"month\",\n  \"password\",\n  \"radio\",\n  \"range\",\n  \"reset\",\n  \"search\",\n  \"submit\",\n  \"tel\",\n  \"text\",\n  \"time\",\n  \"url\",\n  \"week\",\n] as const;\ntype inputType = (typeof inputTypes)[number];\n\ntype SteppableAttr = { value: string; max: string; min: string; step: string };\ntype LengthAble = { value: string; maxlength: string; minlength: string };\ntype InputAttr<inputType> = {\n  id: string;\n  name: string;\n  /**  Tell the browser the input has a valid value before it can be submitted.\n    NOT VALID ON: hidden, range, color, and buttons.\n    @TODO might be fixed in later version  */\n  required?: \"required\";\n} & GlobalAttr &\n  (inputType extends \"button\"\n    ? { type: \"button\"; value: string }\n    : inputType extends \"checkbox\"\n      ? {\n          type: \"checkbox\";\n          value: string;\n          checked?: \"checked\";\n        }\n      : inputType extends \"color\"\n        ? { type: \"color\"; value?: string }\n        : inputType extends \"date\"\n          ? {\n              type: \"date\";\n            } & Partial<SteppableAttr>\n          : inputType extends \"datetime-local\"\n            ? {\n                type: \"datetime-local\";\n              } & Partial<SteppableAttr>\n            : inputType extends \"email\"\n              ? {\n                  type: \"email\";\n                  multiple?: \"multiple\";\n                  pattern?: string;\n                  placeholder?: string;\n                  readonly?: \"readonly\";\n                  size?: string;\n                  list?: string;\n                } & Partial<LengthAble>\n              : inputType extends \"file\"\n                ? {\n                    type: \"file\";\n                    value: \"\";\n                    accept?: \"string\";\n                    capture?: \"user\" | \"environment\";\n                    multiple?: \"multiple\";\n                    webkitdirectory?: \"webkitdirectory\";\n                  }\n                : inputType extends \"hidden\"\n                  ? {\n                      type: \"hidden\";\n                      // if the value is '_charset_' it will set the user-agent as value\n                      value: string | \"_charset_\";\n                    }\n                  : inputType extends \"image\"\n                    ? {\n                        type: \"image\";\n                        src?: string;\n                        alt?: string;\n                        formaction?: string;\n                        formenctype?:\n                          | \"application/x-www-form-urlencoded\"\n                          | \"multipart/form-data\"\n                          | \"text/plain\";\n                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                        formnovalidate?: \"formnovalidate\";\n                        formtarget: targetValues;\n                      }\n                    : inputType extends \"month\"\n                      ? {\n                          type: \"month\";\n                          readonly?: \"readonly\";\n                          list?: string;\n                        } & Partial<SteppableAttr>\n                      : inputType extends \"nubmer\"\n                        ? {\n                            type: \"number\";\n                            list?: string;\n                            placeholder?: string;\n                            readonly?: \"readonly\";\n                          } & Partial<SteppableAttr>\n                        : inputType extends \"password\"\n                          ? {\n                              type: \"password\";\n                              pattern?: string;\n                              /* please use minlength and maxlength in CSS instead*/\n                              size?: string;\n                              readonly?: \"readonly\";\n                              placeholder?: string;\n                              autocomplete?:\n                                | \"on\"\n                                | \"off\"\n                                | \"current-password\"\n                                | \"new-password\";\n                            } & Partial<LengthAble>\n                          : inputType extends \"radio\"\n                            ? {\n                                type: \"radio\";\n                                checked?: \"checked\";\n                              }\n                            : inputType extends \"range\"\n                              ? {\n                                  type: \"range\";\n                                  list: string;\n                                  orient?: \"horizontal\" | \"vertical\";\n                                } & SteppableAttr\n                              : inputType extends \"reset\"\n                                ? {\n                                    type: \"reset\";\n                                  }\n                                : inputType extends \"search\"\n                                  ? {\n                                      type: \"search\";\n                                      value?: string;\n                                      list: string;\n                                      pattern: string;\n                                      placeholder: string;\n                                      readonly: \"readonly\";\n                                      size: string;\n                                      autocorrect?: \"on\" | \"off\";\n                                      incremental?: \"incremental\";\n                                      results?: string;\n                                    } & Partial<LengthAble>\n                                  : inputType extends \"submit\"\n                                    ? {\n                                        type: \"submit\";\n                                        value: string;\n                                        disabled?: \"disabled\";\n                                        formenctype?:\n                                          | \"application/x-www-form-urlencoded\"\n                                          | \"multipart/form-data\"\n                                          | \"text/plain\";\n                                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                                        formnovalidate?: \"formnovalidate\";\n                                        formtarget: targetValues;\n                                      }\n                                    : inputType extends \"tel\"\n                                      ? {\n                                          type: \"tel\";\n                                          list?: string;\n                                          readonly?: \"readonly\";\n                                          size?: string;\n                                          pattern?: string;\n                                        } & Partial<LengthAble>\n                                      : inputType extends \"text\"\n                                        ? {\n                                            type: \"text\";\n                                            list?: string;\n                                            pattern?: string;\n                                            readonly?: \"readonly\";\n                                            placeholder?: string;\n                                          } & Partial<LengthAble>\n                                        : inputType extends \"time\"\n                                          ? {\n                                              type: \"time\";\n                                              list?: string;\n                                              readonly: \"readonly\";\n                                            } & Partial<SteppableAttr>\n                                          : inputType extends \"url\"\n                                            ? {\n                                                type: \"url\";\n                                                list?: string;\n                                                pattern: string;\n                                                placeholder: string;\n                                                readonly?: \"readonly\";\n                                              } & Partial<LengthAble>\n                                            : inputType extends \"week\"\n                                              ? {\n                                                  type: \"week\";\n                                                  readonly?: \"readonly\";\n                                                } & Partial<SteppableAttr>\n                                              : {\n                                                  type: \"Error something went wrong ????\";\n                                                });\n\nexport function Input<inputType>(attrs: InputAttr<inputType>) {\n  const input = document.createElement(\"input\");\n  const attributes = Object.keys(attrs);\n  for (const attr of attributes) {\n    // @ts-ignore\n    input.setAttribute(attr, attrs[attr as any]);\n  }\n  return input;\n}\n\ntype LabelAttr = GlobalAttr & { for: string };\n\nexport function Label(attrs: LabelAttr, ...children: (HTMLElement | Text)[]) {\n  const label = document.createElement(\"label\");\n  const attributes = Object.keys(attrs);\n  for (const attr of attributes) {\n    // @ts-ignore\n    label.setAttribute(attr, attrs[attr]);\n  }\n  for (const c of children) {\n    label.appendChild(c);\n  }\n  return label;\n}\n","/* Elements that should be inside the head */\n\nimport type { targetValues } from \"./attr\";\n\ntype BaseAttrOpt = {\n  href: string;\n  target: targetValues;\n};\n\ntype BaseAttr = Partial<BaseAttrOpt> &\n  (Pick<BaseAttrOpt, \"href\"> | Pick<BaseAttrOpt, \"target\">);\n/**\n * Must be inside <head>\n * If used there should only be 1 inside the document\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n * The <base> HTML element specifies the base URL to use for all relative URLs in a document. There can be only one <base> element in a document.\n *\n *A document's used base URL can be accessed by scripts with Node.baseURI. If the document has no <base> elements, then baseURI defaults to location.href.\n */\nfunction Base(attr: BaseAttr) {\n  const b = document.createElement(\"base\");\n  if (attr.href) b.setAttribute(\"href\", attr.href);\n  if (attr.target) b.setAttribute(\"target\", attr.target);\n  return b;\n}\n/** \n * Sets the document title (this is a void function use it above the return in your render)\n */\nexport function Title(title: string) {\n  document.title = title;\n}\n","import type { GlobalAttr } from \"./attr\";\n\nexport function Address(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"address\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n\nexport function Nav(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"nav\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article */\nexport function Article(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"article\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside */\nexport function Aside(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"aside\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\nexport function Main(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"main\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n\nexport function Button(attributes: GlobalAttr, ...children: HTMLElement[]) {}\n\nexport function Footer(attributes: GlobalAttr, ...children: HTMLElement[]) {\n  const res = document.createElement(\"footer\");\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    res.setAttribute(attr, attributes[attr as keyof GlobalAttr]!);\n  }\n\n  for (const child of children) {\n    res.appendChild(child);\n  }\n\n  return res;\n}\n","/* TODO Strip all the unneccesary stuff out. And transform it into typescript\n *\n ******************FORKED FROM https://github.com/bigskysoftware/idiomorph *******************************************\n * BSD 2-Clause License\n *\n * Copyright (c) 2022, Big Sky Software\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n// @ts-nocheck\n\nlet EMPTY_SET = new Set();\n\n// default configuration values, updatable by users now\nlet defaults = {\n  morphStyle: \"outerHTML\",\n  callbacks: {\n    beforeNodeAdded: noOp,\n    afterNodeAdded: noOp,\n    beforeNodeMorphed: noOp,\n    afterNodeMorphed: noOp,\n    beforeNodeRemoved: noOp,\n    afterNodeRemoved: noOp,\n    beforeAttributeUpdated: noOp,\n  },\n  head: {\n    style: \"merge\",\n    shouldPreserve: function (elt) {\n      return elt.getAttribute(\"im-preserve\") === \"true\";\n    },\n    shouldReAppend: function (elt) {\n      return elt.getAttribute(\"im-re-append\") === \"true\";\n    },\n    shouldRemove: noOp,\n    afterHeadMorphed: noOp,\n  },\n};\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function morph(oldNode, newContent, config = {}) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement;\n  }\n\n  if (typeof newContent === \"string\") {\n    newContent = parseContent(newContent);\n  }\n\n  let normalizedContent = normalizeContent(newContent);\n\n  let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n  return morphNormalizedContent(oldNode, normalizedContent, ctx);\n}\n\nfunction morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n  if (ctx.head.block) {\n    let oldHead = oldNode.querySelector(\"head\");\n    let newHead = normalizedNewContent.querySelector(\"head\");\n    if (oldHead && newHead) {\n      let promises = handleHeadElement(newHead, oldHead, ctx);\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(function () {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        );\n      });\n      return;\n    }\n  }\n\n  if (ctx.morphStyle === \"innerHTML\") {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx);\n    return oldNode.children;\n  } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    let previousSibling = bestMatch?.previousSibling;\n    let nextSibling = bestMatch?.nextSibling;\n\n    // morph it\n    let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(previousSibling, morphedNode, nextSibling);\n    } else {\n      // otherwise nothing was added to the DOM\n      return [];\n    }\n  } else {\n    throw \"Do not understand how to morph style \" + ctx.morphStyle;\n  }\n}\n\n/**\n * @param possibleActiveElement\n * @param ctx\n * @returns {boolean}\n */\nfunction ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n  return (\n    ctx.ignoreActiveValue &&\n    possibleActiveElement === document.activeElement &&\n    possibleActiveElement !== document.body\n  );\n}\n\n/**\n * @param oldNode root node to merge content into\n * @param newContent new content to merge\n * @param ctx the merge context\n * @returns {Element} the element that ended up in the DOM\n */\nfunction morphOldNodeTo(oldNode, newContent, ctx) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n    oldNode.remove();\n    ctx.callbacks.afterNodeRemoved(oldNode);\n    return null;\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n    if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n    oldNode.parentElement.replaceChild(newContent, oldNode);\n    ctx.callbacks.afterNodeAdded(newContent);\n    ctx.callbacks.afterNodeRemoved(oldNode);\n    return newContent;\n  } else {\n    if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)\n      return oldNode;\n\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== \"morph\"\n    ) {\n      handleHeadElement(newContent, oldNode, ctx);\n    } else {\n      syncNodeFrom(newContent, oldNode, ctx);\n      if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n        morphChildren(newContent, oldNode, ctx);\n      }\n    }\n    ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n    return oldNode;\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n * @param {Element} newParent the parent element of the new content\n * @param {Element } oldParent the old content that we are merging the new content into\n * @param ctx the merge context\n */\nfunction morphChildren(newParent, oldParent, ctx) {\n  let nextNewChild = newParent.firstChild;\n  let insertionPoint = oldParent.firstChild;\n  let newChild;\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild;\n    nextNewChild = newChild.nextSibling;\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n      oldParent.appendChild(newChild);\n      ctx.callbacks.afterNodeAdded(newChild);\n      removeIdsFromConsideration(ctx, newChild);\n      continue;\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n      morphOldNodeTo(insertionPoint, newChild, ctx);\n      insertionPoint = insertionPoint.nextSibling;\n      removeIdsFromConsideration(ctx, newChild);\n      continue;\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(\n      newParent,\n      oldParent,\n      newChild,\n      insertionPoint,\n      ctx,\n    );\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n      morphOldNodeTo(idSetMatch, newChild, ctx);\n      removeIdsFromConsideration(ctx, newChild);\n      continue;\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(\n      newParent,\n      oldParent,\n      newChild,\n      insertionPoint,\n      ctx,\n    );\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n      morphOldNodeTo(softMatch, newChild, ctx);\n      removeIdsFromConsideration(ctx, newChild);\n      continue;\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n    oldParent.insertBefore(newChild, insertionPoint);\n    ctx.callbacks.afterNodeAdded(newChild);\n    removeIdsFromConsideration(ctx, newChild);\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint;\n    insertionPoint = insertionPoint.nextSibling;\n    removeNode(tempNode, ctx);\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\n/**\n * @param attr {String} the attribute to be mutated\n * @param to {Element} the element that is going to be updated\n * @param updateType {(\"update\"|\"remove\")}\n * @param ctx the merge context\n * @returns {boolean} true if the attribute should be ignored, false otherwise\n */\nfunction ignoreAttribute(attr, to, updateType, ctx) {\n  if (\n    attr === \"value\" &&\n    ctx.ignoreActiveValue &&\n    to === document.activeElement\n  ) {\n    return true;\n  }\n  return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n}\n\n/**\n * syncs a given node with another node, copying over all attributes and\n * inner element state from the 'from' node to the 'to' node\n *\n * @param {Element} from the element to copy attributes & state from\n * @param {Element} to the element to copy attributes & state to\n * @param ctx the merge context\n */\nfunction syncNodeFrom(from, to, ctx) {\n  let type = from.nodeType;\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const fromAttributes = from.attributes;\n    const toAttributes = to.attributes;\n    for (const fromAttribute of fromAttributes) {\n      if (ignoreAttribute(fromAttribute.name, to, \"update\", ctx)) {\n        continue;\n      }\n      if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value);\n      }\n    }\n    // iterate backwards to avoid skipping over items when a delete occurs\n    for (let i = toAttributes.length - 1; 0 <= i; i--) {\n      const toAttribute = toAttributes[i];\n      if (ignoreAttribute(toAttribute.name, to, \"remove\", ctx)) {\n        continue;\n      }\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name);\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue;\n    }\n  }\n\n  if (!ignoreValueOfActiveElement(to, ctx)) {\n    // sync input values\n    syncInputValue(from, to, ctx);\n  }\n}\n\n/**\n * @param from {Element} element to sync the value from\n * @param to {Element} element to sync the value to\n * @param attributeName {String} the attribute name\n * @param ctx the merge context\n */\nfunction syncBooleanAttribute(from, to, attributeName, ctx) {\n  if (from[attributeName] !== to[attributeName]) {\n    let ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n    if (!ignoreUpdate) {\n      to[attributeName] = from[attributeName];\n    }\n    if (from[attributeName]) {\n      if (!ignoreUpdate) {\n        to.setAttribute(attributeName, from[attributeName]);\n      }\n    } else {\n      if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n        to.removeAttribute(attributeName);\n      }\n    }\n  }\n}\n\n/**\n * NB: many bothans died to bring us information:\n *\n *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n *\n * @param from {Element} the element to sync the input value from\n * @param to {Element} the element to sync the input value to\n * @param ctx the merge context\n */\nfunction syncInputValue(from, to, ctx) {\n  if (\n    from instanceof HTMLInputElement &&\n    to instanceof HTMLInputElement &&\n    from.type !== \"file\"\n  ) {\n    let fromValue = from.value;\n    let toValue = to.value;\n\n    // sync boolean attributes\n    syncBooleanAttribute(from, to, \"checked\", ctx);\n    syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n    if (!from.hasAttribute(\"value\")) {\n      if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n        to.value = \"\";\n        to.removeAttribute(\"value\");\n      }\n    } else if (fromValue !== toValue) {\n      if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        to.setAttribute(\"value\", fromValue);\n        to.value = fromValue;\n      }\n    }\n  } else if (from instanceof HTMLOptionElement) {\n    syncBooleanAttribute(from, to, \"selected\", ctx);\n  } else if (\n    from instanceof HTMLTextAreaElement &&\n    to instanceof HTMLTextAreaElement\n  ) {\n    let fromValue = from.value;\n    let toValue = to.value;\n    if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n      return;\n    }\n    if (fromValue !== toValue) {\n      to.value = fromValue;\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue;\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(newHeadTag, currentHead, ctx) {\n  let added = [];\n  let removed = [];\n  let preserved = [];\n  let nodesToAppend = [];\n\n  let headMergeStyle = ctx.head.style;\n\n  // put all new head elements into a Map, by their outerHTML\n  let srcToNewHeadNodes = new Map();\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n    let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n    let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt);\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n        preserved.push(currentHeadElt);\n      }\n    } else {\n      if (headMergeStyle === \"append\") {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt);\n          nodesToAppend.push(currentHeadElt);\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n          removed.push(currentHeadElt);\n        }\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values());\n  log(\"to append: \", nodesToAppend);\n\n  let promises = [];\n  for (const newNode of nodesToAppend) {\n    log(\"adding: \", newNode);\n    let newElt = document\n      .createRange()\n      .createContextualFragment(newNode.outerHTML).firstChild;\n    log(newElt);\n    if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n      if (newElt.href || newElt.src) {\n        let resolve = null;\n        let promise = new Promise(function (_resolve) {\n          resolve = _resolve;\n        });\n        newElt.addEventListener(\"load\", function () {\n          resolve();\n        });\n        promises.push(promise);\n      }\n      currentHead.appendChild(newElt);\n      ctx.callbacks.afterNodeAdded(newElt);\n      added.push(newElt);\n    }\n  }\n\n  // remove all removed elements, after we have appended the new elements to avoid\n  // additional network requests for things like style sheets\n  for (const removedElement of removed) {\n    if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n      currentHead.removeChild(removedElement);\n      ctx.callbacks.afterNodeRemoved(removedElement);\n    }\n  }\n\n  ctx.head.afterHeadMorphed(currentHead, {\n    added: added,\n    kept: preserved,\n    removed: removed,\n  });\n  return promises;\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\n\nfunction log() {\n  //console.log(arguments);\n}\n\nfunction noOp() {}\n\n/*\n      Deep merges the config object and the Idiomoroph.defaults object to\n      produce a final configuration object\n     */\nfunction mergeDefaults(config) {\n  let finalConfig = {};\n  // copy top level stuff into final config\n  Object.assign(finalConfig, defaults);\n  Object.assign(finalConfig, config);\n\n  // copy callbacks into final config (do this to deep merge the callbacks)\n  finalConfig.callbacks = {};\n  Object.assign(finalConfig.callbacks, defaults.callbacks);\n  Object.assign(finalConfig.callbacks, config.callbacks);\n\n  // copy head config into final config  (do this to deep merge the head)\n  finalConfig.head = {};\n  Object.assign(finalConfig.head, defaults.head);\n  Object.assign(finalConfig.head, config.head);\n  return finalConfig;\n}\n\nfunction createMorphContext(oldNode, newContent, config) {\n  config = mergeDefaults(config);\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    ignoreActiveValue: config.ignoreActiveValue,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    callbacks: config.callbacks,\n    head: config.head,\n  };\n}\n\nfunction isIdSetMatch(node1, node2, ctx) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1.id !== \"\" && node1.id === node2.id) {\n      return true;\n    } else {\n      return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n  }\n  return false;\n}\n\nfunction isSoftMatch(node1, node2) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(startInclusive, endExclusive, ctx) {\n  while (startInclusive !== endExclusive) {\n    let tempNode = startInclusive;\n    startInclusive = startInclusive.nextSibling;\n    removeNode(tempNode, ctx);\n  }\n  removeIdsFromConsideration(ctx, endExclusive);\n  return endExclusive.nextSibling;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n  // max id matches we are willing to discard in our search\n  let newChildPotentialIdCount = getIdIntersectionCount(\n    ctx,\n    newChild,\n    oldParent,\n  );\n\n  let potentialMatch = null;\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    let potentialMatch = insertionPoint;\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0;\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch;\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(\n        ctx,\n        potentialMatch,\n        newContent,\n      );\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null;\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling;\n    }\n  }\n  return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n  let potentialSoftMatch = insertionPoint;\n  let nextSibling = newChild.nextSibling;\n  let siblingSoftMatchCount = 0;\n\n  while (potentialSoftMatch != null) {\n    if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null;\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch;\n    }\n\n    if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++;\n      nextSibling = nextSibling.nextSibling;\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null;\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling;\n  }\n\n  return potentialSoftMatch;\n}\n\nfunction parseContent(newContent) {\n  let parser = new DOMParser();\n\n  // remove svgs to avoid false-positive matches on head, etc.\n  let contentWithSvgsRemoved = newContent.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    \"\",\n  );\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    let content = parser.parseFromString(newContent, \"text/html\");\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      content.generatedByIdiomorph = true;\n      return content;\n    } else {\n      // otherwise return the html element as the parent container\n      let htmlElement = content.firstChild;\n      if (htmlElement) {\n        htmlElement.generatedByIdiomorph = true;\n        return htmlElement;\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    let responseDoc = parser.parseFromString(\n      \"<body><template>\" + newContent + \"</template></body>\",\n      \"text/html\",\n    );\n    let content = responseDoc.body.querySelector(\"template\").content;\n    content.generatedByIdiomorph = true;\n    return content;\n  }\n}\n\nfunction normalizeContent(newContent) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement(\"div\");\n    return dummyParent;\n  } else if (newContent.generatedByIdiomorph) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent;\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement(\"div\");\n    dummyParent.append(newContent);\n    return dummyParent;\n  } else {\n    // all nodes in the array or HTMLElement collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement(\"div\");\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt);\n    }\n    return dummyParent;\n  }\n}\n\nfunction insertSiblings(previousSibling, morphedNode, nextSibling) {\n  let stack = [];\n  let added = [];\n  while (previousSibling != null) {\n    stack.push(previousSibling);\n    previousSibling = previousSibling.previousSibling;\n  }\n  while (stack.length > 0) {\n    let node = stack.pop();\n    added.push(node); // push added preceding siblings on in order and insert\n    morphedNode.parentElement.insertBefore(node, morphedNode);\n  }\n  added.push(morphedNode);\n  while (nextSibling != null) {\n    stack.push(nextSibling);\n    added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling;\n  }\n  while (stack.length > 0) {\n    morphedNode.parentElement.insertBefore(\n      stack.pop(),\n      morphedNode.nextSibling,\n    );\n  }\n  return added;\n}\n\nfunction findBestNodeMatch(newContent, oldNode, ctx) {\n  let currentElement;\n  currentElement = newContent.firstChild;\n  let bestElement = currentElement;\n  let score = 0;\n  while (currentElement) {\n    let newScore = scoreElement(currentElement, oldNode, ctx);\n    if (newScore > score) {\n      bestElement = currentElement;\n      score = newScore;\n    }\n    currentElement = currentElement.nextSibling;\n  }\n  return bestElement;\n}\n\nfunction scoreElement(node1, node2, ctx) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n  }\n  return 0;\n}\n\nfunction removeNode(tempNode, ctx) {\n  removeIdsFromConsideration(ctx, tempNode);\n  if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n  tempNode.remove();\n  ctx.callbacks.afterNodeRemoved(tempNode);\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx, id) {\n  return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx, id, targetNode) {\n  let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n  return idSet.has(id);\n}\n\nfunction removeIdsFromConsideration(ctx, node) {\n  let idSet = ctx.idMap.get(node) || EMPTY_SET;\n  for (const id of idSet) {\n    ctx.deadIds.add(id);\n  }\n}\n\nfunction getIdIntersectionCount(ctx, node1, node2) {\n  let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n  let matchCount = 0;\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount;\n    }\n  }\n  return matchCount;\n}\n\n/**\n * A bottom up algorithm that finds all elements with ids inside of the node\n * argument and populates id sets for those nodes and all their parents, generating\n * a set of ids contained within all nodes for the entire hierarchy in the DOM\n *\n * @param node {Element}\n * @param {Map<Node, Set<String>>} idMap\n */\nfunction populateIdMapForNode(node, idMap) {\n  let nodeParent = node.parentElement;\n  // find all elements with an id property\n  let idElements = node.querySelectorAll(\"[id]\");\n  for (const elt of idElements) {\n    let current = elt;\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && current != null) {\n      let idSet = idMap.get(current);\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set();\n        idMap.set(current, idSet);\n      }\n      idSet.add(elt.id);\n      current = current.parentElement;\n    }\n  }\n}\n\n/**\n * This function computes a map of nodes to all ids contained within that node (inclusive of the\n * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n * to contribute to a parent nodes matching.\n *\n * @param {Element} oldContent  the old content that will be morphed\n * @param {Element} newContent  the new content to morph to\n * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n */\nfunction createIdMap(oldContent, newContent) {\n  let idMap = new Map();\n  populateIdMapForNode(oldContent, idMap);\n  populateIdMapForNode(newContent, idMap);\n  return idMap;\n}\n","import { morph } from \"./morphing\";\n\nexport type WhateverComponent = Comp<any>;\n\nclass Comp<K extends any> {\n  render: (data: K, comp: Comp<K>) => HTMLElement;\n  childComps: WhateverComponent[] = [];\n  protected parent: WhateverComponent;\n  protected data: K;\n  protected changed = true;\n  public getParent() {\n    return this.parent;\n  }\n\n  /**\n   * Usefull when updating before the component needs to be rendered!\n   */\n  public UpdateNoRender(data: K) {\n    this.data = data;\n    this.changed = true;\n  }\n\n  public Update(newData: K) {\n    this.data = newData;\n    this.changed = true;\n    this.Render();\n  }\n\n  /** The current dom element*/\n  public currentRender: HTMLElement;\n\n  /** Get a (shallow) copy of the array of children */\n  public getChildren() {\n    return [...this.childComps];\n  }\n\n  /** Returns the child */\n  public addChild(c: WhateverComponent) {\n    //@ts-ignore\n    if (c == this) {\n      throw Error(\"Can't add yourself as a child!?\");\n    }\n    this.childComps.push(c);\n  }\n  public removeChild(c: WhateverComponent) {\n    this.childComps = this.childComps.filter((ch) => c != ch);\n  }\n\n  public Render(force = false) {\n    if (!(this.changed || force)) {\n      return this.currentRender;\n    }\n    const newR = this.render(this.data, this);\n    for (const c of this.childComps) {\n      c.Render(force);\n    }\n\n    morph(this.currentRender, newR, {});\n\n    this.changed = false;\n    return this.currentRender;\n  }\n\n  constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement\n  ) {\n    this.render = render;\n    this.data = data;\n    this.parent = parent;\n    this.currentRender = this.render(data, this);\n  }\n}\n\nlet rc: undefined | RootComp = undefined;\nexport function RootComponent() {\n  if (rc) return rc;\n  rc = new RootComp();\n  return rc;\n}\n\nclass RootComp extends Comp<undefined> {\n  constructor() {\n    super(undefined as any, undefined, () => {\n      // hacky method that works because the Root render does nothing and is equal the the previous render\n      return document.body;\n    });\n    this.parent = this as WhateverComponent;\n  }\n}\n\n/** A component can be used to Bind a Value to a Render */\nexport function Component<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement\n) {\n  const comp = new Comp(parent, data, render);\n\n  return comp;\n}\n\nexport type WhateverPageComponent = PageComp<any>;\n/**\n *\n * @param pageLoad Function is called when the route-path and matches the route this registered with in the 'pagehandler'. NOTE WHEN USING .Update ON COMPONENT IT WILL RENDER!!! (if you do so use no render)\n */\nexport class PageComp<K extends any> extends Comp<K> {\n  removeAllChildren() {\n    this.childComps = [];\n  }\n  onPageLoad: (data: K, comp: PageComp<K>) => void;\n\n  OnPageLoad() {\n    this.onPageLoad(this.data, this);\n  }\n\n  public constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n    onPageLoad: (data: K, comp: PageComp<K>) => void\n  ) {\n    super(parent, data, render);\n    this.onPageLoad = onPageLoad;\n  }\n}\n\nexport function PageComponent<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n  onPageLoad: (data: K, comp: PageComp<K>) => void\n) {\n  return new PageComp(parent, data, render, onPageLoad);\n}\n","type eventType = keyof HTMLElementEventMap;\n\nexport function WithEventListener<T extends eventType, K extends HTMLElement>(\n  el: K,\n  eventtype: T,\n  listener: (ev: HTMLElementEventMap[T]) => void,\n): K {\n  el.addEventListener(eventtype, listener);\n  return el;\n}\n","import { type WhateverPageComponent } from \"../reactive/component\";\nimport { navigateTo } from \"./navigate\";\n\ntype routeItem = {\n  path: string;\n  route: RegExp;\n  comp: WhateverPageComponent;\n  params: paramItem[];\n};\n\ntype paramItem = {\n  pos: number;\n  name: string;\n  value?: string;\n};\n\nexport class PageRegister {\n  public Anchor: HTMLElement;\n  public routes: routeItem[];\n\n  public currentPage: WhateverPageComponent | undefined;\n  public currentRoute: routeItem | undefined;\n  /**\n   * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n   * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n   */\n  public registerRoute(route: string, comp: WhateverPageComponent) {\n    const routesplit = route.split(\"/\");\n    let resultStr = \"\";\n\n    const params: paramItem[] = [];\n\n    const splitLen = routesplit.length;\n    if (splitLen == 0 || route == \"/\") {\n      resultStr = \"/\";\n    } else {\n      for (let i = 0; i < splitLen; i++) {\n        const s = routesplit[i];\n        if (!s || s.length == 0) {\n          continue;\n        }\n        if (s[0] == \"[\" && s[s.length - 1] == \"]\") {\n          const name = s.split(\"[\")[1]!.split(\"]\")[0];\n          const nparam = {\n            name: name!,\n            pos: i,\n          } satisfies paramItem;\n          params.push(nparam);\n          resultStr += `\\/[A-Za-z1-9_\\\\-]+`;\n\n          continue;\n        }\n        resultStr += `\\/${s}`;\n      }\n    }\n    const routeI = {\n      comp: comp,\n      params: params,\n      path: route,\n      route: new RegExp(resultStr),\n    } satisfies routeItem;\n    if (this.routes.find((a) => a.route == routeI.route)) {\n      throw new Error(\n        `Route already exist '${route}'.\\nRegex: '${routeI.route.source}'\\nRouteData: ${JSON.stringify(routeI)}`,\n      );\n    }\n\n    this.routes.push(routeI);\n    return this;\n  }\n\n  public getParamValue(name: string) {\n    if (this.currentRoute) {\n      for (const p of this.currentRoute.params) {\n        if (p.name == name) {\n          return p.value;\n        }\n      }\n    }\n  }\n\n  public enable() {\n    // TODO not populate the window space (with this prefix it should really matter)\n    (window as any).__$HFX__Register = this;\n    window.addEventListener(\"popstate\", onPageChange);\n    onPageChange();\n    return this;\n  }\n\n  public constructor(anchor: HTMLElement) {\n    this.Anchor = anchor;\n    this.routes = [];\n  }\n}\n\n/**\n * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n */\nexport function RouteRegister(el: HTMLElement) {\n  return new PageRegister(el);\n}\n\nfunction onPageChange() {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n\n  // reset the current values\n  reg.currentPage = undefined;\n\n  if (reg.currentRoute) {\n    reg.currentRoute.comp.removeAllChildren();\n    for (const p of reg.currentRoute.params) {\n      p.value = undefined;\n    }\n  }\n  reg.currentRoute = undefined;\n\n  const url = window.location.pathname;\n  // load the current page\n  for (const r of reg.routes) {\n    const match = url.match(r.route);\n    reg.currentRoute = r;\n    if (match && match[0].length >= url.length) {\n      const splits = url.split(\"/\");\n      for (const p of r.params) {\n        p.value = splits[p.pos];\n      }\n      r.comp.OnPageLoad();\n      reg.Anchor.replaceChildren(r.comp.Render(true));\n      reg.currentPage = r.comp;\n      return;\n    }\n  }\n  // nothing found => 404 page\n  if (url.startsWith(\"/404\") || url.startsWith(\"404\")) {\n    return;\n  }\n  navigateTo(`/404?page=${url}`);\n}\n\nexport function GetParamValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.getParamValue(name);\n  }\n  return undefined;\n}\n","/**\n * Fetch JSON\n */\nexport const fetcher = {\n  post,\n};\n\ninterface FetchResult<T> {\n  result: T | undefined;\n  /**\n   * Status will be 0 if err is caused by an exception\n   *\n   */\n  err: { status: number; name: string; cause: string | object } | undefined;\n}\n\n/**\n *\n * @param url\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function get<T>(\n  url: string,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined,\n): Promise<FetchResult<T>> {\n  let res: FetchResult<T> = { result: undefined, err: undefined };\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"GET\";\n\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  await fetch(url, requestInit)\n    .then(async (val) => {\n      if (val.ok && val.status >= 200 && val.status <= 299) {\n        res.result = await val.json();\n      } else {\n        res.err = {\n          name: `Status: ${val.status} => ${val.statusText}`,\n          cause: \"Request did not succees!\",\n          status: val.status,\n        } as any;\n      }\n    })\n    .catch((e) => {\n      res.err = e;\n      res.err!.status = 0;\n    })\n    .finally(() => {});\n  return res;\n}\n\n/**\n *\n * @param url\n * @param body\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {body} or {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function post<T>(\n  url: string,\n  body: string | null | undefined,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined,\n): Promise<FetchResult<T>> {\n  let res: FetchResult<T> = { result: undefined, err: undefined };\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"POST\";\n  if (body) {\n    requestInit.body = body;\n  }\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  await fetch(url, requestInit)\n    .then(async (val) => {\n      if (val.ok && val.status >= 200 && val.status <= 299) {\n        res.result = await val.json();\n      } else {\n        res.err = {\n          name: `Status: ${val.status} => ${val.statusText}`,\n          cause: \"Request did not succees!\",\n          status: val.status,\n        } as any;\n      }\n    })\n    .catch((e) => {\n      res.err = e;\n      res.err!.status = 0;\n    })\n    .finally(() => {});\n  return res;\n}\n"],"mappings":"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","names":["t","t","potentialMatch"]}