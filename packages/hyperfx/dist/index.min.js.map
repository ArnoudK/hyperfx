{"version":3,"file":"index.min.js","sources":["../src/elem/elem.ts","../src/elem/headings.ts","../src/pages/navigate.ts","../src/elem/head.ts","../src/elem/table.ts","../src/reactive/morphing.ts","../src/reactive/component.ts","../src/pages/register.ts","../src/fetcher.ts","../src/json_representation/hfx_object.ts","../src/index.ts","../src/elem/text.ts","../src/elem/semantic.ts","../src/elem/style.ts","../src/elem/img.ts","../src/elem/input.ts"],"sourcesContent":["import type { GlobalAttr, HtmlAtrribute } from \"./attr\";\n\nexport type HtmlElement_Or_Text_Children_Or_Undefined =\n  | readonly (Element | Text)[]\n  | undefined;\n\nexport type TextChildren_Or_Undefined = readonly Element[] | undefined;\n\nexport const Div = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"div\", attributes, children);\n\n/** Render text (the text content inside a tag): */\nexport function t(text: TemplateStringsArray | string, ...values: ((string[]))) {\n  let result = \"\";\n  if (typeof text === \"string\") {\n    // If the input is a string, just return it\n    result = text;\n  } else {\n    // Iterate through the static strings and interleave them with the values\n    for (let i = 0; i < values.length; i++) {\n      result += text[i]; // Append the static string part\n      result += String(values[i]); // Append the stringified value\n    }\n    // Append the last static string part\n    // (there's always one more string part than there are values)\n    result += text[values.length];\n  }\n  return document.createTextNode(result);\n}\nconst a = t`kek`\n\nexport const RenderToBody = (el: HTMLElement) => document.body.appendChild(el);\n\nexport const addAttr = (el: Element, attributes: object) => {\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n};\n\nexport const addChildren = (\n  e: Element,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => {\n  if (children)\n    for (const c of children) {\n      e.appendChild(c);\n    }\n};\n\nexport const createS = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  return el;\n};\n\nexport const createE = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  if (children) {\n    for (const c of children) {\n      el.appendChild(c);\n    }\n  }\n  return el;\n};\n","import type { GlobalAttr } from \"./attr\";\nimport { createE } from \"./elem\";\n\ntype heads = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n\nconst Head = (t: heads, attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(t, attributes, children);\n\nexport const H1 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h1\", attributes, children);\n\nexport const H2 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h2\", attributes, children);\n\nexport const H3 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h3\", attributes, children);\n\nexport const H4 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h4\", attributes, children);\n\nexport const H5 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h5\", attributes, children);\n\nexport const H6 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h6\", attributes, children);\n","/**\n * Navigate to a url by pushing it and popstate this allows for soft navigation using HyperFX\n * The URL must be registered in the PageRegister!!!\n */\nexport function navigateTo(href: string) {\n  history.pushState({}, \"\", href);\n  window.dispatchEvent(new Event(\"popstate\"));\n}\n","/* Elements that should be inside the head */\n\nimport type { targetValues } from \"./attr\";\nimport { createS } from \"./elem\";\n\ntype BaseAttrOpt = {\n  href: string;\n  target: targetValues;\n};\n\ntype BaseAttr = Partial<BaseAttrOpt> &\n  (Pick<BaseAttrOpt, \"href\"> | Pick<BaseAttrOpt, \"target\">);\n/**\n * Must be inside <head>\n * If used there should only be 1 inside the document\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n * The <base> HTML element specifies the base URL to use for all relative URLs in a document. There can be only one <base> element in a document.\n *\n *A document's used base URL can be accessed by scripts with Node.baseURI. If the document has no <base> elements, then baseURI defaults to location.href.\n */\nexport function Base(attr: BaseAttr) {\n  const b = document.createElement(\"base\");\n  if (attr.href) b.setAttribute(\"href\", attr.href);\n  if (attr.target) b.setAttribute(\"target\", attr.target);\n  return b;\n}\n/**\n * Sets or updates the meta description in the head\n */\nexport function MetaDescription(description: string) {\n  const current = document.head.querySelector('meta[name=\"description\"]');\n  if (current) {\n    current.setAttribute(\"content\", description);\n  } else {\n    document.head.appendChild(\n      createS(\"meta\", { name: \"description\", content: description })\n    );\n  }\n}\n\n/**\n * Sets or updates the document title (this is a void function use it above the return in your render)\n */\nexport const Title = (title: string) => (document.title = title);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\n/** <caption> <thead> <tbody> <tfooter>\n * also accepts <tr> directly\n * But it seems like using a <tbody> is preffered by the new standards\n */\ntype tableChild =\n  | HTMLTableSectionElement\n  | HTMLTableCaptionElement\n  | HTMLTableRowElement;\n\nexport const Table = (\n  attributes: GlobalAttr,\n  children?: readonly tableChild[]\n) => createE(\"table\", attributes, children);\n\nexport const TableHead = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"thead\", attributes, children);\n\nexport const Thead = TableHead;\n\nexport const TableBody = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tbody\", attributes, children);\n\nexport const Tbody = TableBody;\n\nexport const TableFoot = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tfoot\", attributes, children);\n\nexport const Tfoot = TableFoot;\n\n/** Only <td> and <th> */\ntype tableRowChild = HTMLTableCellElement;\n\nexport const TableRow = (\n  attributes: GlobalAttr,\n  children?: readonly tableRowChild[]\n) => createE(\"tr\", attributes, children);\n\nexport const Tr = TableRow;\n\nexport const TableData = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"td\", attributes, children);\n\nexport const Td = TableData;\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attributes */\ntype tableHeaderAttributes = GlobalAttr & {\n  scope?: \"row\" | \"col\" | \"rowgroup\" | \"colgroup\";\n  abbr?: string;\n  colspan?: string;\n  headers?: string;\n  rowspan?: string;\n};\n\nexport const TableHeader = (\n  attributes: tableHeaderAttributes,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"th\", attributes, children);\n\nexport const Th = TableHeader;\n\n/* Caption for tables */\nexport const TableCaption = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"caption\", attributes, children);\n","/* TODO Strip all the unneccesary stuff out. And transform it into typescript\n *\n ******************FORKED FROM https://github.com/bigskysoftware/idiomorph *******************************************\n * BSD 2-Clause License\n *\n * Copyright (c) 2022, Big Sky Software\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nconst EMPTY_SET: Set<string> = new Set();\n\n// default configuration values, updatable by users now\nconst defaults = {\n  morphStyle: \"outerHTML\" as \"innerHTML\" | \"outerHTML\",\n  deadIds: new Set<string>(),\n  head: {\n    block: false as boolean,\n    ignore: false as boolean,\n    style: \"morph\" as \"morph\" | \"append\",\n    shouldPreserve: (elt: Element) => {\n      return elt.getAttribute(\"im-preserve\") === \"true\";\n    },\n    shouldReAppend: (elt: Element) => {\n      return elt.getAttribute(\"im-re-append\") === \"true\";\n    },\n  },\n} as const;\n\ntype contextType = typeof defaults & {\n  newContent: MorphEl;\n  ignoreActive: boolean;\n  ignoreActiveValue: boolean;\n  target: MorphEl | null;\n  config: contextType;\n  idMap: Map<MorphEl, Set<string>>;\n};\n\ntype MorphNode = Node & { generatedByIdiomorph?: boolean };\ntype MorphEl = Element & { generatedByIdiomorph?: boolean };\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function morph(\n  oldNode: MorphNode | MorphEl,\n  newContent: MorphNode | MorphEl | string | null,\n  config: Partial<contextType> = {},\n) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement;\n  }\n\n  if (typeof newContent === \"string\") {\n    newContent = parseContent(newContent) as MorphEl;\n  }\n\n  const normalizedContent = normalizeContent(newContent);\n\n  const ctx = createMorphContext(\n    oldNode as MorphEl,\n    normalizedContent as MorphEl,\n    config as contextType,\n  );\n\n  return morphNormalizedContent(\n    oldNode as any,\n    normalizedContent as MorphEl,\n    ctx,\n  );\n}\n\nfunction morphNormalizedContent(\n  oldNode: MorphEl,\n  normalizedNewContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector(\"head\");\n    const newHead = normalizedNewContent.querySelector(\"head\");\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx);\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(function () {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        );\n      });\n      return;\n    }\n  }\n\n  if (ctx.morphStyle === \"innerHTML\") {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx);\n    return oldNode.children;\n  } else {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling;\n    const nextSibling = bestMatch?.nextSibling;\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch as MorphEl, ctx);\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(\n        previousSibling as MorphEl,\n        morphedNode as MorphEl,\n        nextSibling as MorphEl,\n      );\n    } else {\n      // otherwise nothing was added to the DOM\n      return [];\n    }\n  }\n}\n\nfunction ignoreValueOfActiveElement(\n  possibleActiveElement: MorphEl,\n  ctx: contextType,\n) {\n  return (\n    ctx.ignoreActiveValue &&\n    possibleActiveElement === document.activeElement &&\n    possibleActiveElement !== document.body\n  );\n}\n\nfunction morphOldNodeTo(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    oldNode.remove();\n\n    return null;\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    oldNode.parentElement!.replaceChild(newContent, oldNode);\n\n    return newContent;\n  } else {\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== \"morph\"\n    ) {\n      handleHeadElement(newContent, oldNode, ctx);\n    } else {\n      syncNodeFrom(newContent, oldNode, ctx);\n      if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n        morphChildren(newContent, oldNode, ctx);\n      }\n    }\n    return oldNode;\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n */\nfunction morphChildren(\n  newParent: MorphEl,\n  oldParent: MorphEl,\n  ctx: contextType,\n) {\n  let nextNewChild = newParent.firstChild;\n  let insertionPoint = oldParent.firstChild;\n  let newChild;\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild;\n    nextNewChild = newChild.nextSibling;\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      oldParent.appendChild(newChild);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild as MorphEl, insertionPoint as MorphEl, ctx)) {\n      morphOldNodeTo(insertionPoint as MorphEl, newChild as MorphEl, ctx);\n      insertionPoint = insertionPoint.nextSibling;\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(\n      newParent,\n      oldParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n      morphOldNodeTo(idSetMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(\n      newParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n      morphOldNodeTo(softMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n\n    oldParent.insertBefore(newChild, insertionPoint);\n    removeIdsFromConsideration(ctx, newChild as MorphEl);\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint;\n    insertionPoint = insertionPoint.nextSibling;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\nfunction ignoreAttribute(\n  attr: string,\n  to: MorphEl,\n  updateType: \"update\" | \"remove\",\n  ctx: contextType,\n) {\n  if (\n    attr === \"value\" &&\n    ctx.ignoreActiveValue &&\n    to === document.activeElement\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction syncNodeFrom(from: MorphEl, to: MorphEl, ctx: contextType) {\n  const type = from.nodeType;\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const fromAttributes = from.attributes;\n    const toAttributes = to.attributes;\n    for (const fromAttribute of fromAttributes) {\n      if (ignoreAttribute(fromAttribute.name, to, \"update\", ctx)) {\n        continue;\n      }\n      if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value);\n      }\n    }\n    // iterate backwards to avoid skipping over items when a delete occurs\n    for (let i = toAttributes.length - 1; 0 <= i; i--) {\n      const toAttribute = toAttributes[i]!;\n      if (ignoreAttribute(toAttribute.name, to, \"remove\", ctx)) {\n        continue;\n      }\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name);\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue;\n    }\n  }\n\n  if (!ignoreValueOfActiveElement(to, ctx)) {\n    // sync input values\n    syncInputValue(from, to, ctx);\n  }\n}\n\nfunction syncBooleanAttribute(\n  from: MorphEl,\n  to: MorphEl,\n  attributeName: string,\n  ctx: contextType,\n) {\n  if ((from as any)[attributeName] !== (to as any)[attributeName]) {\n    const ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n    if (!ignoreUpdate) {\n      (to as any) = (from as any)[attributeName];\n    }\n    if ((from as any)[attributeName]) {\n      if (!ignoreUpdate) {\n        to.setAttribute(attributeName, (from as any)[attributeName]);\n      }\n    } else {\n      if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n        to.removeAttribute(attributeName);\n      }\n    }\n  }\n}\n\nfunction syncInputValue(from: MorphEl, to: MorphEl, ctx: contextType) {\n  if (\n    from instanceof HTMLInputElement &&\n    to instanceof HTMLInputElement &&\n    from.type !== \"file\"\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n\n    // sync boolean attributes\n    syncBooleanAttribute(from, to, \"checked\", ctx);\n    syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n    if (!from.hasAttribute(\"value\")) {\n      if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n        to.value = \"\";\n        to.removeAttribute(\"value\");\n      }\n    } else if (fromValue !== toValue) {\n      if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        to.setAttribute(\"value\", fromValue);\n        to.value = fromValue;\n      }\n    }\n  } else if (from instanceof HTMLOptionElement) {\n    syncBooleanAttribute(from, to, \"selected\", ctx);\n  } else if (\n    from instanceof HTMLTextAreaElement &&\n    to instanceof HTMLTextAreaElement\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n    if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n      return;\n    }\n    if (fromValue !== toValue) {\n      to.value = fromValue;\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue;\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n  newHeadTag: MorphEl,\n  currentHead: MorphEl,\n  ctx: contextType,\n) {\n  const removed = [];\n  const preserved = [];\n  const nodesToAppend = [];\n\n  const headMergeStyle = ctx.head.style;\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map();\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    const inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n    const isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n    const isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt);\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n        preserved.push(currentHeadElt);\n      }\n    } else {\n      if (headMergeStyle === \"append\") {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt);\n          nodesToAppend.push(currentHeadElt);\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n\n        removed.push(currentHeadElt);\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values());\n\n  for (const newNode of nodesToAppend) {\n    const newElt = document\n      .createRange()\n      .createContextualFragment(newNode.outerHTML).firstChild;\n  }\n\n  return [];\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\n\n/*\n      Deep merges the config object and the Idiomoroph.defaults object to\n      produce a final configuration object\n     */\nfunction mergeDefaults(config: Partial<contextType>) {\n  const finalConfig: Partial<contextType> = {};\n  // copy top level stuff into final config\n  Object.assign(finalConfig, defaults);\n  Object.assign(finalConfig, config);\n\n  // copy head config into final config  (do this to deep merge the head)\n  (finalConfig as any).head = {};\n  Object.assign(finalConfig.head as any, defaults.head);\n  Object.assign(finalConfig.head as any, config.head);\n  return finalConfig;\n}\n\nfunction createMorphContext(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  config: contextType,\n): contextType {\n  config = mergeDefaults(config) as any;\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    ignoreActiveValue: config.ignoreActiveValue,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    head: config.head,\n  };\n}\n\nfunction isIdSetMatch(\n  node1: null | MorphEl,\n  node2: MorphEl | null,\n  ctx: contextType,\n) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1.id !== \"\" && node1.id === node2.id) {\n      return true;\n    } else {\n      return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n  }\n  return false;\n}\n\nfunction isSoftMatch(node1: MorphEl | null, node2: MorphEl | null) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n  startInclusive: MorphNode | null,\n  endExclusive: MorphNode | null,\n  ctx: contextType,\n) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive;\n    startInclusive = startInclusive!.nextSibling!;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n  removeIdsFromConsideration(ctx, endExclusive as MorphEl);\n  return endExclusive!.nextSibling!;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n  newContent: MorphNode,\n  oldParent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(\n    ctx,\n    newChild,\n    oldParent as MorphEl,\n  );\n\n  const potentialMatch = null;\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    let potentialMatch = insertionPoint;\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0;\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch;\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(\n        ctx,\n        potentialMatch,\n        newContent as MorphEl,\n      );\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null;\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as MorphEl;\n    }\n  }\n  return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n  newContent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  let potentialSoftMatch = insertionPoint;\n  let nextSibling = newChild.nextSibling;\n  let siblingSoftMatchCount = 0;\n\n  while (potentialSoftMatch != null) {\n    if (\n      getIdIntersectionCount(ctx, potentialSoftMatch, newContent as MorphEl) > 0\n    ) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null;\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch;\n    }\n\n    if (isSoftMatch(nextSibling as MorphEl, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++;\n      nextSibling = nextSibling!.nextSibling;\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null;\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as null | MorphEl;\n  }\n\n  return potentialSoftMatch;\n}\n\nfunction parseContent(newContent: string) {\n  const parser = new DOMParser();\n\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    \"\",\n  );\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, \"text/html\");\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      (content as MorphNode).generatedByIdiomorph = true;\n      return content;\n    } else {\n      // otherwise return the html element as the parent container\n      const htmlElement: MorphNode | null = content.firstChild;\n      if (htmlElement) {\n        htmlElement.generatedByIdiomorph = true;\n        return htmlElement;\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(\n      \"<body><template>\" + newContent + \"</template></body>\",\n      \"text/html\",\n    );\n    const content = responseDoc.body.querySelector(\"template\")!.content;\n    (content as MorphNode).generatedByIdiomorph = true;\n    return content;\n  }\n}\n\nfunction normalizeContent(newContent: null | MorphEl | MorphNode) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement(\"div\");\n    return dummyParent;\n  } else if (newContent.generatedByIdiomorph) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent;\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement(\"div\");\n    dummyParent.append(newContent);\n    return dummyParent;\n  } else {\n    // all nodes in the array or HTMLElement collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement(\"div\");\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt);\n    }\n    return dummyParent;\n  }\n}\n\nfunction insertSiblings(\n  previousSibling: MorphEl | null,\n  morphedNode: MorphEl,\n  nextSibling: MorphEl | null,\n) {\n  const stack: MorphEl[] = [];\n  const added = [];\n  while (previousSibling != null) {\n    stack.push(previousSibling);\n    previousSibling = previousSibling.previousSibling as MorphEl | null;\n  }\n  while (stack.length > 0) {\n    const node = stack.pop();\n    added.push(node); // push added preceding siblings on in order and insert\n    morphedNode.parentElement!.insertBefore(node as MorphEl, morphedNode);\n  }\n  added.push(morphedNode);\n  while (nextSibling != null) {\n    stack.push(nextSibling);\n    added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as MorphEl;\n  }\n  while (stack.length > 0) {\n    morphedNode.parentElement!.insertBefore(\n      stack.pop() as MorphEl,\n      morphedNode.nextSibling,\n    );\n  }\n  return added;\n}\n\nfunction findBestNodeMatch(\n  newContent: MorphEl,\n  oldNode: MorphEl,\n  ctx: contextType,\n) {\n  let currentElement;\n  currentElement = newContent.firstChild;\n  let bestElement = currentElement;\n  let score = 0;\n  while (currentElement) {\n    const newScore = scoreElement(currentElement as MorphEl, oldNode, ctx);\n    if (newScore > score) {\n      bestElement = currentElement;\n      score = newScore;\n    }\n    currentElement = currentElement.nextSibling;\n  }\n  return bestElement;\n}\n\nfunction scoreElement(node1: MorphEl, node2: MorphEl, ctx: contextType) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n  }\n  return 0;\n}\n\nfunction removeNode(tempNode: MorphEl, ctx: contextType) {\n  removeIdsFromConsideration(ctx, tempNode);\n\n  tempNode.remove();\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: contextType, id: string) {\n  return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: contextType, id: string, targetNode: MorphEl) {\n  const idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n  return idSet.has(id);\n}\n\nfunction removeIdsFromConsideration(ctx: contextType, node: MorphEl) {\n  const idSet = ctx.idMap.get(node) || EMPTY_SET;\n  for (const id of idSet) {\n    // @ts-ignore\n    ctx.deadIds.add(id);\n  }\n}\n\nfunction getIdIntersectionCount(\n  ctx: contextType,\n  node1: MorphEl,\n  node2: MorphEl,\n) {\n  const sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n  let matchCount = 0;\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount;\n    }\n  }\n  return matchCount;\n}\n\nfunction populateIdMapForNode(node: MorphEl, idMap: Map<Node, Set<string>>) {\n  const nodeParent = node.parentElement;\n  // find all elements with an id property\n  const idElements = node.querySelectorAll(\"[id]\");\n  for (const elt of idElements) {\n    let current = elt;\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && current != null) {\n      let idSet = idMap.get(current);\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set();\n        idMap.set(current, idSet);\n      }\n      idSet.add(elt.id);\n      current = current.parentElement!;\n    }\n  }\n}\n\nfunction createIdMap(oldContent: MorphEl, newContent: MorphEl) {\n  const idMap: Map<MorphEl, Set<string>> = new Map();\n  populateIdMapForNode(oldContent, idMap);\n  populateIdMapForNode(newContent, idMap);\n  return idMap;\n}\n\n/// END OF MORPHING ////\n","import { morph } from \"./morphing\";\n\nexport type WhateverComponent = Comp<any>;\n\nclass Comp<K extends any> {\n  render: (data: K, comp: Comp<K>) => HTMLElement;\n  childComps: WhateverComponent[] = [];\n  protected parent: WhateverComponent;\n  public data: K;\n  protected changed = true;\n  public getParent() {\n    return this.parent;\n  }\n\n  /**\n   * Usefull when updating before the component needs to be rendered!\n   */\n  public UpdateNoRender(data: K) {\n    this.data = data;\n    this.changed = true;\n  }\n\n  public Update(newData: K) {\n    this.data = newData;\n    this.changed = true;\n    this.Render(true);\n  }\n\n  /** The current dom element*/\n  public currentRender: HTMLElement;\n\n  /** Get a (shallow) copy of the array of children */\n  public getChildren() {\n    return [...this.childComps];\n  }\n\n  /** Returns the child */\n  public addChild(c: WhateverComponent) {\n    //@ts-ignore\n    if (c == this) {\n      throw Error(\"Can't add yourself as a child!?\");\n    }\n    this.childComps.push(c);\n  }\n  public removeChild(c: WhateverComponent) {\n    this.childComps = this.childComps.filter((ch) => c != ch);\n  }\n\n  public Render(force = false) {\n    if (!(this.changed || force)) {\n      return this.currentRender;\n    }\n    const newR = this.render(this.data, this);\n    for (const c of this.childComps) {\n      c.Render(force);\n    }\n\n    morph(this.currentRender, newR, {});\n\n    this.changed = false;\n    return this.currentRender;\n  }\n\n  constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n  ) {\n    this.render = render;\n    this.data = data;\n    this.parent = parent;\n    this.currentRender = this.render(data, this);\n  }\n}\n\nlet rc: undefined | RootComp = undefined;\nexport function RootComponent() {\n  if (rc) return rc;\n  rc = new RootComp();\n  return rc;\n}\n\nclass RootComp extends Comp<undefined> {\n  constructor() {\n    super(undefined as any, undefined, () => {\n      // hacky method that works because the Root render does nothing and is equal the the previous render\n      return document.body;\n    });\n    this.parent = this as WhateverComponent;\n  }\n}\n\n/** A component can be used to Bind a Value to a Render */\nexport function Component<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n) {\n  const comp = new Comp(parent, data, render);\n\n  return comp;\n}\n\nexport type WhateverPageComponent = PageComp<any>;\n/**\n *\n * @param OnPageLoad Function is called when the route-path and matches the route this registered with in the 'pagehandler'. NOTE WHEN USING .Update ON COMPONENT IT WILL RENDER!!! (if you do so use no render)\n */\nexport class PageComp<K extends any> extends Comp<K> {\n  removeAllChildren() {\n    this.childComps = [];\n  }\n  onPageLoad: (data: K, comp: PageComp<K>) => void;\n\n  OnPageLoad() {\n    this.onPageLoad(this.data, this);\n  }\n\n  public constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n    onPageLoad: (data: K, comp: PageComp<K>) => void,\n  ) {\n    super(parent, data, render);\n    this.onPageLoad = onPageLoad;\n  }\n}\n\nexport function PageComponent<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n  onPageLoad: (data: K, comp: PageComp<K>) => void,\n) {\n  return new PageComp(parent, data, render, onPageLoad);\n}\n","import { type WhateverPageComponent } from \"../reactive/component\";\nimport { navigateTo } from \"./navigate\";\n\ntype routeItem = {\n  path: string;\n  route: RegExp;\n  comp: WhateverPageComponent;\n  params: paramItem[];\n};\n\ntype paramItem = {\n  pos: number;\n  name: string;\n  value?: string;\n};\n\nexport class PageRegister {\n  public Anchor: HTMLElement;\n  public routes: routeItem[];\n\n  public currentPage: WhateverPageComponent | undefined;\n  public currentRoute: routeItem | undefined;\n\n  public queryParams: URLSearchParams;\n  /**\n   * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n   * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n   */\n  public registerRoute(route: string, comp: WhateverPageComponent) {\n    const routesplit = route.split(\"/\");\n    let resultStr = \"\";\n\n    const params: paramItem[] = [];\n\n    const splitLen = routesplit.length;\n    if (splitLen == 0 || route == \"/\") {\n      resultStr = \"/\";\n    } else {\n      for (let i = 0; i < splitLen; i++) {\n        const s = routesplit[i];\n        if (!s || s.length == 0) {\n          continue;\n        }\n        if (s[0] == \"[\" && s[s.length - 1] == \"]\") {\n          const name = s.split(\"[\")[1]!.split(\"]\")[0];\n          const nparam = {\n            name: name!,\n            pos: i,\n          } satisfies paramItem;\n          params.push(nparam);\n          resultStr += `\\/[A-Za-z1-9_\\\\-]+`;\n\n          continue;\n        }\n        resultStr += \"/\" + s;\n      }\n    }\n    const routeI = {\n      comp: comp,\n      params: params,\n      path: route,\n      route: new RegExp(resultStr),\n    } satisfies routeItem;\n    if (this.routes.find((a) => a.route == routeI.route)) {\n      throw new Error(\n        `Route already exist '${route}'.\\nRegex: '${routeI.route.source}'\\nRouteData: ${JSON.stringify(routeI)}`,\n      );\n    }\n\n    this.routes.push(routeI);\n    return this;\n  }\n\n  public getParamValue(name: string) {\n    if (this.currentRoute) {\n      for (const p of this.currentRoute.params) {\n        if (p.name == name) {\n          return p.value;\n        }\n      }\n    }\n  }\n\n  public enable() {\n    // TODO not populate the window space (with this prefix it should really matter)\n    (window as any).__$HFX__Register = this;\n    window.addEventListener(\"popstate\", onPageChange);\n    onPageChange();\n    return this;\n  }\n\n  public constructor(anchor: HTMLElement) {\n    this.Anchor = anchor;\n    this.routes = [];\n    this.queryParams = new URLSearchParams(window.location.search);\n  }\n}\n\n/**\n * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n */\nexport function RouteRegister(el: HTMLElement) {\n  return new PageRegister(el);\n}\n\nfunction onPageChange() {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n\n  // reset the current values\n  reg.currentPage = undefined;\n\n  if (reg.currentRoute) {\n    reg.currentRoute.comp.removeAllChildren();\n    for (const p of reg.currentRoute.params) {\n      p.value = undefined;\n    }\n  }\n  reg.currentRoute = undefined;\n\n  reg.queryParams = new URLSearchParams(window.location.search);\n  let url = window.location.pathname;\n  // take care of trailing /\n  if (url.length > 1 && url.at(-1) == \"/\") {\n    url = url.slice(0, url.length - 1);\n  }\n  // load the current page\n  for (const r of reg.routes) {\n    const match = url.match(r.route);\n    reg.currentRoute = r;\n    if (match && match[0].length >= url.length) {\n      const splits = url.split(\"/\");\n      for (const p of r.params) {\n        p.value = splits[p.pos];\n      }\n      r.comp.OnPageLoad();\n      reg.Anchor.replaceChildren(r.comp.Render(true));\n      reg.currentPage = r.comp;\n      return;\n    }\n  }\n\n  // nothing found => 404 page\n  if (url.startsWith(\"/404\") || url.startsWith(\"404\")) {\n    return;\n  }\n  navigateTo(`/404?page=${url}`);\n}\n\n/** Get a param value from the current Route */\nexport function GetParamValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.getParamValue(name);\n  }\n  return undefined;\n}\n\n/** Get a query param (?name=value) value from the current url */\nexport function GetQueryValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.get(name);\n  }\n  return null;\n}\n\n/** Get an array[] with all query params that match the name (?name=value&name=otherValue) from the current url*/\nexport function GetQueryValues(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.getAll(name);\n  }\n  return [];\n}\n","/**\n * Fetch JSON\n */\nexport const fetcher = {\n  post,\n  get,\n};\n\ninterface FetchResult<T, K extends boolean> {\n  succes: K;\n  result: K extends true ? T : undefined;\n  /**\n   * Status will be 0 if err is caused by an exception\n   *\n   */\n  err: K extends false\n    ? { status: number; name: string; cause: string | object }\n    : undefined;\n}\n\n/**\n *\n * @param url\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function get<T>(\n  url: string,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"GET\";\n\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const fetch_result = await fetch(url, requestInit);\n\n    if (\n      fetch_result.ok &&\n      fetch_result.status >= 200 &&\n      fetch_result.status <= 299\n    ) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await fetch_result.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${fetch_result.status} => ${fetch_result.statusText}`,\n          cause: \"Request did not succees!\",\n          status: fetch_result.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n\n/**\n *\n * @param url\n * @param body\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {body} or {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function post<T>(\n  url: string,\n  body: string | null | undefined,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"POST\";\n  if (body) {\n    requestInit.body = body;\n  }\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const val = await fetch(url, requestInit);\n    if (val.ok && val.status >= 200 && val.status <= 299) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await val.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${val.status} => ${val.statusText}`,\n          cause: \"Request did not succees!\",\n          status: val.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n","type attributes = Record<string, string>;\nexport type HFXObject =\n  | {\n      tag: string;\n      attrs: attributes;\n      children: HFXObject[];\n    }\n  | string;\n\n/**\n * convert an Element to a HFXObject\n * this object can be turned into a JSON-string\n * and be turned into a Element again\n * (note: it stores the current state and not stuff like\n * listeners )\n */\nexport function elementToHFXObject(el: Element): HFXObject {\n  const tag = el.tagName;\n  const attrs: attributes = {};\n  const children: HFXObject[] = [];\n  const cNodes = el.childNodes;\n  const elAttrs = el.attributes;\n  for (const a of elAttrs) {\n    const aname = a.name;\n    const value = a.value;\n    (attrs as any)[aname] = value;\n  }\n\n  for (const c of cNodes) {\n    children.push(nodeToHFXObject(c));\n  }\n\n  return { tag: tag, attrs: attrs, children: children };\n}\n/**\n * @see elementToHFXObject\n *\n * Parse stuff from the dom to simple JS object\n * mainly for json parsing.\n */\nexport function nodeToHFXObject(node: Node) {\n  if (node instanceof Text) {\n    return (node as Text).textContent ?? \"\";\n  } else {\n    // we assert that this should work because\n    // we shouldn't really deal with strange fragments\n    // other other shenigans.\n    return elementToHFXObject(node as Element);\n  }\n}\n\nexport function HFXObjectToElement(hfx_object: HFXObject): Text | Element {\n  if (typeof hfx_object == \"string\") {\n    return document.createTextNode(hfx_object);\n  }\n  const el = document.createElement(hfx_object.tag);\n  for (const c of hfx_object.children) {\n    el.appendChild(HFXObjectToElement(c));\n  }\n  const akeys = Object.keys( hfx_object.attrs);\n  for (const a of akeys) {\n    el.setAttribute(a, hfx_object.attrs[a]!);\n  }\n\n  return el;\n}\n","import { Div, RenderToBody, t } from \"./elem/elem\";\nimport { H1, H2, H3, H4, H5, H6 } from \"./elem/headings\";\nimport { Img } from \"./elem/img\";\nimport { Input, Label } from \"./elem/input\";\nimport { Br, Hr } from \"./elem/style\";\nimport {\n  A,\n  Abbr,\n  B,\n  Bdi,\n  Bdo,\n  Cite,\n  I,\n  P,\n  Span,\n  Code,\n  BlockQuote,\n} from \"./elem/text\";\n\nimport { MetaDescription, Title, Base } from \"./elem/head\";\n\nimport {\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Tr,\n} from \"./elem/table\";\n\nimport {\n  Address,\n  Article,\n  Aside,\n  Button,\n  Footer,\n  Main,\n  Output,\n  Pre,\n  Nav,\n} from \"./elem/semantic\";\n\nimport { Component, PageComponent, RootComponent } from \"./reactive/component\";\n\nimport { navigateTo } from \"./pages/navigate\";\n\nimport {\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  RouteRegister,\n} from \"./pages/register\";\n\nimport { fetcher } from \"./fetcher\";\n\nimport {\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n} from \"./json_representation/hfx_object\";\nimport type { HFXObject } from \"./json_representation/hfx_object\";\n\n/* Extension methods */\n\nObject.defineProperty(HTMLElement.prototype, \"WithEvent$HFX\", {\n  value: function <T extends HTMLElement, K extends keyof HTMLElementEventMap>(\n    this: T,\n    eventtype: K,\n    listener: (ev: HTMLElementEventMap[K]) => void\n  ) {\n    this.addEventListener(eventtype, listener);\n    return this;\n  },\n});\n\nObject.defineProperty(Object.prototype, \"With$HFX\", {\n  value: function <T extends Object>(this: T, func: (obj: T) => void) {\n    func(this);\n    return this;\n  },\n});\n\ndeclare global {\n  interface HTMLElement {\n    /** Add an event listener and return the Element */\n    WithEvent$HFX<K extends keyof HTMLElementEventMap>(\n      eventtype: K,\n      listener: (ev: HTMLElementEventMap[K]) => void\n    ): this;\n  }\n  interface Object {\n    With$HFX<T extends Object>(this: T, run: (obj: T) => void): T;\n  }\n}\n\nexport {\n  /* HTML Tags */\n  A,\n  Abbr,\n  Address,\n  Article,\n  Aside,\n  B,\n  Base,\n  Bdi,\n  Bdo,\n  Br,\n  BlockQuote,\n  Button,\n  Cite,\n  Code,\n  /* Components */\n  Component,\n  Div,\n  /* fetcher */\n  fetcher,\n  Footer,\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n  H6,\n  Hr,\n  I,\n  Img,\n  Input,\n  Label,\n  Main,\n  MetaDescription,\n  Nav,\n  /* Routing */\n  navigateTo,\n  P,\n  PageComponent,\n  Pre,\n  Output,\n  /* Other DOM stuff */\n  RenderToBody,\n  RootComponent,\n  RouteRegister,\n  Span,\n  t,\n  /* Table stuff */\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Title,\n  Tr,\n  // json_representation\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n};\n\nexport type { HFXObject };\n","import { navigateTo } from \"../pages/navigate\";\nimport type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  addAttr,\n  addChildren,\n  createE,\n  t,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n  type TextChildren_Or_Undefined,\n} from \"./elem\";\n/**\n    * this file is for Elements with phrasing content that should have text as children\n    * Phrasing context:  https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#phrasing_content\n    But only the ones that are not just semantic divs\n    */\n\nexport function Span(\n  attributes: GlobalAttr,\n  childOrText: string | HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = document.createElement(\"span\");\n  addAttr(res, attributes);\n  if (typeof childOrText === \"string\") {\n    res.appendChild(t(childOrText));\n  } else {\n    addChildren(res, childOrText);\n  }\n  return res;\n}\n\n\n\n\nexport const P = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"p\", attributes, children);\n\nexport const Abbr = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(\"abbr\", attributes, children);\n\ntype anchorAttr = Partial<GlobalAttr> & {\n  href: string;\n  target?: targetValues;\n  download?: \"download\";\n  filename?: string;\n  hreflang?: string;\n  ping?: string;\n  referrerpolicy?:\n  | \"no-referrer\"\n  | \"no-referrer-when-downgrade\"\n  | \"origin\"\n  | \"origin-when-cross-origin\"\n  | \"same-origin\"\n  | \"strict-origin\"\n  | \"strict-origin-when-cross-origin\"\n  | \"unsafe-url\";\n  rel?: string;\n};\n\nexport function A(\n  attributes: anchorAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = createE(\"a\", attributes, children);\n  if (attributes.href[0] == \"/\") {\n    res.addEventListener(\"click\", (ev) => {\n      navigateTo((ev.target as HTMLAnchorElement).href);\n      ev.preventDefault();\n      return false;\n    });\n  }\n  return res;\n}\n\nexport const B = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"b\", attributes, children);\n\nexport const Bdi = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdi\", attributes, children);\n\nexport const Bdo = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdo\", attributes, children);\n\nexport const I = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"i\", attributes, children);\n\nexport const Cite = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"cite\", attributes, children);\n\nexport const Code = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"code\", attributes, children);\n\nexport const BlockQuote = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"blockquote\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\nexport const Address = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"address\", attributes, children);\n\nexport const Nav = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"nav\", attributes, children);\n\nexport const Pre = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"pre\", attributes, children);\n\nexport const Output = (\n  attributes: GlobalAttr & { for: string; name: string },\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"output\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article */\nexport const Article = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"article\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside */\nexport const Aside = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"aside\", attributes, children);\n\nexport const Main = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"main\", attributes, children);\n\nexport const Button = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"button\", attributes, children);\n\nexport const Footer = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"footer\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport { createS } from \"./elem\";\n\nexport const Br = (attributes: GlobalAttr) => createS(\"br\", attributes);\n\nexport const Hr = (attributes: GlobalAttr) => createS(\"hr\", attributes);\n","import type { GlobalAttr } from \"./attr\";\nimport { addAttr, createS } from \"./elem\";\n\ntype requiredImgAttr = { src: string };\ntype optionImgAttr = {\n  alt: string;\n  attributionsrc: string;\n  crossorigin: \"anonymous\" | \"use-credentials\";\n  decoding: \"sync\" | \"async\" | \"auto\";\n  elementtiming: string;\n  fetchpriority: \"high\" | \"low\" | \"auto\";\n  height: string;\n  width: string;\n  loading: \"eager\" | \"lazy\";\n  referrerpolicy:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  sizes: string;\n  srcset: string;\n};\n\ntype imageAttr = requiredImgAttr & GlobalAttr & Partial<optionImgAttr>;\n\nexport const Img = (attrs: imageAttr) => createS(\"img\", attrs);\n","import type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  createE,\n  createS,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\ntype inputRequired = {\n  type:\n    | \"button\"\n    | \"checkbox\"\n    | \"color\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"email\"\n    | \"file\"\n    | \"hidden\"\n    | \"image\"\n    | \"month\"\n    | \"password\"\n    | \"radio\"\n    | \"range\"\n    | \"reset\"\n    | \"search\"\n    | \"submit\"\n    | \"tel\"\n    | \"text\"\n    | \"time\"\n    | \"url\"\n    | \"week\";\n  /**   @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#name\n        '_charset_' combined with hidden will set the value to the 'user-agent'\n        'isindex' is not allowed as name\n         */\n  name: string | \"_charset_\";\n  id: string;\n};\n\nconst inputTypes = [\n  \"button\",\n  \"checkbox\",\n  \"color\",\n  \"date\",\n  \"datetime-local\",\n  \"email\",\n  \"file\",\n  \"hidden\",\n  \"image\",\n  \"month\",\n  \"password\",\n  \"radio\",\n  \"range\",\n  \"reset\",\n  \"search\",\n  \"submit\",\n  \"tel\",\n  \"text\",\n  \"time\",\n  \"url\",\n  \"week\",\n] as const;\ntype inputType = (typeof inputTypes)[number];\n\ntype SteppableAttr = { value: string; max: string; min: string; step: string };\ntype LengthAble = { value: string; maxlength: string; minlength: string };\ntype InputAttr<inputType> = {\n  id: string;\n  name: string;\n  /**  Tell the browser the input has a valid value before it can be submitted.\n    NOT VALID ON: hidden, range, color, and buttons.\n    @TODO might be fixed in later version  */\n  required?: \"required\";\n} & GlobalAttr &\n  (inputType extends \"button\"\n    ? { type: \"button\"; value: string }\n    : inputType extends \"checkbox\"\n      ? {\n          type: \"checkbox\";\n          value: string;\n          checked?: \"checked\";\n        }\n      : inputType extends \"color\"\n        ? { type: \"color\"; value?: string }\n        : inputType extends \"date\"\n          ? {\n              type: \"date\";\n            } & Partial<SteppableAttr>\n          : inputType extends \"datetime-local\"\n            ? {\n                type: \"datetime-local\";\n              } & Partial<SteppableAttr>\n            : inputType extends \"email\"\n              ? {\n                  type: \"email\";\n                  multiple?: \"multiple\";\n                  pattern?: string;\n                  placeholder?: string;\n                  readonly?: \"readonly\";\n                  size?: string;\n                  list?: string;\n                } & Partial<LengthAble>\n              : inputType extends \"file\"\n                ? {\n                    type: \"file\";\n                    value: \"\";\n                    accept?: \"string\";\n                    capture?: \"user\" | \"environment\";\n                    multiple?: \"multiple\";\n                    webkitdirectory?: \"webkitdirectory\";\n                  }\n                : inputType extends \"hidden\"\n                  ? {\n                      type: \"hidden\";\n                      // if the value is '_charset_' it will set the user-agent as value\n                      value: string | \"_charset_\";\n                    }\n                  : inputType extends \"image\"\n                    ? {\n                        type: \"image\";\n                        src?: string;\n                        alt?: string;\n                        formaction?: string;\n                        formenctype?:\n                          | \"application/x-www-form-urlencoded\"\n                          | \"multipart/form-data\"\n                          | \"text/plain\";\n                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                        formnovalidate?: \"formnovalidate\";\n                        formtarget?: targetValues;\n                      }\n                    : inputType extends \"month\"\n                      ? {\n                          type: \"month\";\n                          readonly?: \"readonly\";\n                          list?: string;\n                        } & Partial<SteppableAttr>\n                      : inputType extends \"nubmer\"\n                        ? {\n                            type: \"number\";\n                            list?: string;\n                            placeholder?: string;\n                            readonly?: \"readonly\";\n                          } & Partial<SteppableAttr>\n                        : inputType extends \"password\"\n                          ? {\n                              type: \"password\";\n                              pattern?: string;\n                              /* please use minlength and maxlength in CSS instead*/\n                              size?: string;\n                              readonly?: \"readonly\";\n                              placeholder?: string;\n                              autocomplete?:\n                                | \"on\"\n                                | \"off\"\n                                | \"current-password\"\n                                | \"new-password\";\n                            } & Partial<LengthAble>\n                          : inputType extends \"radio\"\n                            ? {\n                                type: \"radio\";\n                                checked?: \"checked\";\n                              }\n                            : inputType extends \"range\"\n                              ? {\n                                  type: \"range\";\n                                  list: string;\n                                  orient?: \"horizontal\" | \"vertical\";\n                                } & SteppableAttr\n                              : inputType extends \"reset\"\n                                ? {\n                                    type: \"reset\";\n                                  }\n                                : inputType extends \"search\"\n                                  ? {\n                                      type: \"search\";\n                                      value?: string;\n                                      list: string;\n                                      pattern: string;\n                                      placeholder: string;\n                                      readonly: \"readonly\";\n                                      size: string;\n                                      autocorrect?: \"on\" | \"off\";\n                                      incremental?: \"incremental\";\n                                      results?: string;\n                                    } & Partial<LengthAble>\n                                  : inputType extends \"submit\"\n                                    ? {\n                                        type: \"submit\";\n                                        value: string;\n                                        disabled?: \"disabled\";\n                                        formenctype?:\n                                          | \"application/x-www-form-urlencoded\"\n                                          | \"multipart/form-data\"\n                                          | \"text/plain\";\n                                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                                        formnovalidate?: \"formnovalidate\";\n                                        formtarget: targetValues;\n                                      }\n                                    : inputType extends \"tel\"\n                                      ? {\n                                          type: \"tel\";\n                                          list?: string;\n                                          readonly?: \"readonly\";\n                                          size?: string;\n                                          pattern?: string;\n                                        } & Partial<LengthAble>\n                                      : inputType extends \"text\"\n                                        ? {\n                                            type: \"text\";\n                                            list?: string;\n                                            pattern?: string;\n                                            readonly?: \"readonly\";\n                                            placeholder?: string;\n                                          } & Partial<LengthAble>\n                                        : inputType extends \"time\"\n                                          ? {\n                                              type: \"time\";\n                                              list?: string;\n                                              readonly: \"readonly\";\n                                            } & Partial<SteppableAttr>\n                                          : inputType extends \"url\"\n                                            ? {\n                                                type: \"url\";\n                                                list?: string;\n                                                pattern: string;\n                                                placeholder: string;\n                                                readonly?: \"readonly\";\n                                              } & Partial<LengthAble>\n                                            : inputType extends \"week\"\n                                              ? {\n                                                  type: \"week\";\n                                                  readonly?: \"readonly\";\n                                                } & Partial<SteppableAttr>\n                                              : {\n                                                  type: \"Error something went wrong ????\";\n                                                });\n\nexport const Input = (attrs: InputAttr<inputType>) => createS(\"input\", attrs);\n\ntype LabelAttr = GlobalAttr & { for: string };\n\nexport const Label = (\n  attrs: LabelAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"label\", attrs, children);\n\nexport const TextArea = (\n  attrs: GlobalAttr &\n    Partial<LengthAble> &\n    Partial<{ cols: number; rows: number; required: \"required\" }> &\n    Partial<{ name: string; id: string; value: string }>\n) => {\n  createS(\"textarea\", attrs);\n};\n"],"names":["t","text","values","result","i","length","String","document","createTextNode","createS","name","attributes","el","createElement","attrs","Object","keys","attr","setAttribute","createE","children","c","appendChild","Head","navigateTo","href","history","pushState","window","dispatchEvent","Event","TableHead","Thead","TableBody","Tbody","TableFoot","Tfoot","TableRow","Tr","TableData","Td","TableHeader","Th","EMPTY_SET","Set","defaults","morphStyle","deadIds","head","block","ignore","style","shouldPreserve","elt","getAttribute","shouldReAppend","morph","oldNode","newContent","config","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","content","parseFromString","generatedByIdiomorph","htmlElement","firstChild","body","querySelector","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","ctx","finalConfig","assign","mergeDefaults","target","ignoreActive","ignoreActiveValue","idMap","createIdMap","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","Promise","all","then","morphChildren","bestMatch","currentElement","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","push","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","activeElement","remove","isSoftMatch","HTMLHeadElement","from","to","type","nodeType","fromAttributes","toAttributes","fromAttribute","ignoreAttribute","value","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","newNode","createRange","createContextualFragment","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","idIsWithinNode","targetNode","get","idSet","add","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","oldContent","Comp","getParent","this","parent","UpdateNoRender","data","changed","Update","newData","Render","getChildren","childComps","addChild","Error","removeChild","filter","ch","force","currentRender","newR","render","constructor","rc","RootComp","super","undefined","PageComp","removeAllChildren","OnPageLoad","onPageLoad","PageRegister","registerRoute","route","comp","routesplit","split","resultStr","params","splitLen","s","nparam","pos","routeI","path","RegExp","routes","find","a","source","JSON","stringify","getParamValue","currentRoute","p","enable","__$HFX__Register","addEventListener","onPageChange","anchor","Anchor","queryParams","URLSearchParams","location","search","reg","currentPage","url","pathname","at","slice","r","splits","replaceChildren","startsWith","fetcher","post","async","headers","requestInit","method","val","fetch","ok","status","succes","err","json","statusText","cause","e","res","fetch_result","elementToHFXObject","tag","cNodes","childNodes","elAttrs","aname","nodeToHFXObject","Text","textContent","defineProperty","HTMLElement","prototype","eventtype","listener","func","exports","A","ev","preventDefault","Abbr","Address","Article","Aside","B","Base","b","Bdi","Bdo","BlockQuote","Br","Button","Cite","Code","Component","Div","Footer","GetParamValue","GetQueryValue","GetQueryValues","getAll","H1","H2","H3","H4","H5","H6","HFXObjectToElement","hfx_object","akeys","Hr","I","Img","Input","Label","Main","MetaDescription","description","Nav","Output","P","PageComponent","Pre","RenderToBody","RootComponent","RouteRegister","Span","childOrText","addAttr","addChildren","Table","TableCaption","Title","title"],"mappings":"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"}