{"version":3,"file":"index.min.js","sources":["../src/elem/elem.ts","../src/elem/headings.ts","../src/pages/navigate.ts","../src/elem/head.ts","../src/elem/table.ts","../src/reactive/morphing.ts","../src/reactive/component.ts","../src/pages/register.ts","../src/fetcher.ts","../src/json_representation/hfx_object.ts","../src/index.ts","../src/elem/text.ts","../src/elem/semantic.ts","../src/elem/style.ts","../src/elem/img.ts","../src/elem/input.ts"],"sourcesContent":["import type { GlobalAttr, HtmlAtrribute } from \"./attr\";\n\nexport type HtmlElement_Or_Text_Children_Or_Undefined =\n  | readonly (Element | Text)[]\n  | undefined;\n\nexport type TextChildren_Or_Undefined = readonly Element[] | undefined;\n\nexport const Div = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"div\", attributes, children);\n\n/** Render text (the text content inside a tag): */\nexport const t = (t: string) => document.createTextNode(t);\n\nexport const RenderToBody = (el: HTMLElement) => document.body.appendChild(el);\n\nexport const addAttr = (el: Element, attributes: object) => {\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n};\n\nexport const addChildren = (\n  e: Element,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => {\n  if (children)\n    for (const c of children) {\n      e.appendChild(c);\n    }\n};\n\nexport const createS = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  return el;\n};\n\nexport const createE = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  if (children) {\n    for (const c of children) {\n      el.appendChild(c);\n    }\n  }\n  return el;\n};\n","import type { GlobalAttr } from \"./attr\";\nimport { createE } from \"./elem\";\n\ntype heads = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n\nconst Head = (t: heads, attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(t, attributes, children);\n\nexport const H1 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h1\", attributes, children);\n\nexport const H2 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h2\", attributes, children);\n\nexport const H3 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h3\", attributes, children);\n\nexport const H4 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h4\", attributes, children);\n\nexport const H5 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h5\", attributes, children);\n\nexport const H6 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h6\", attributes, children);\n","/**\n * Navigate to a url by pushing it and popstate this allows for soft navigation using HyperFX\n * The URL must be registered in the PageRegister!!!\n */\nexport function navigateTo(href: string) {\n  history.pushState({}, \"\", href);\n  window.dispatchEvent(new Event(\"popstate\"));\n}\n","/* Elements that should be inside the head */\n\nimport type { targetValues } from \"./attr\";\nimport { createS } from \"./elem\";\n\ntype BaseAttrOpt = {\n  href: string;\n  target: targetValues;\n};\n\ntype BaseAttr = Partial<BaseAttrOpt> &\n  (Pick<BaseAttrOpt, \"href\"> | Pick<BaseAttrOpt, \"target\">);\n/**\n * Must be inside <head>\n * If used there should only be 1 inside the document\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n * The <base> HTML element specifies the base URL to use for all relative URLs in a document. There can be only one <base> element in a document.\n *\n *A document's used base URL can be accessed by scripts with Node.baseURI. If the document has no <base> elements, then baseURI defaults to location.href.\n */\nexport function Base(attr: BaseAttr) {\n  const b = document.createElement(\"base\");\n  if (attr.href) b.setAttribute(\"href\", attr.href);\n  if (attr.target) b.setAttribute(\"target\", attr.target);\n  return b;\n}\n/**\n * Sets or updates the meta description in the head\n */\nexport function MetaDescription(description: string) {\n  const current = document.head.querySelector('meta[name=\"description\"]');\n  if (current) {\n    current.setAttribute(\"content\", description);\n  } else {\n    document.head.appendChild(\n      createS(\"meta\", { name: \"description\", content: description })\n    );\n  }\n}\n\n/**\n * Sets or updates the document title (this is a void function use it above the return in your render)\n */\nexport const Title = (title: string) => (document.title = title);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\n/** <caption> <thead> <tbody> <tfooter>\n * also accepts <tr> directly\n * But it seems like using a <tbody> is preffered by the new standards\n */\ntype tableChild =\n  | HTMLTableSectionElement\n  | HTMLTableCaptionElement\n  | HTMLTableRowElement;\n\nexport const Table = (\n  attributes: GlobalAttr,\n  children?: readonly tableChild[]\n) => createE(\"table\", attributes, children);\n\nexport const TableHead = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"thead\", attributes, children);\n\nexport const Thead = TableHead;\n\nexport const TableBody = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tbody\", attributes, children);\n\nexport const Tbody = TableBody;\n\nexport const TableFoot = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tfoot\", attributes, children);\n\nexport const Tfoot = TableFoot;\n\n/** Only <td> and <th> */\ntype tableRowChild = HTMLTableCellElement;\n\nexport const TableRow = (\n  attributes: GlobalAttr,\n  children?: readonly tableRowChild[]\n) => createE(\"tr\", attributes, children);\n\nexport const Tr = TableRow;\n\nexport const TableData = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"td\", attributes, children);\n\nexport const Td = TableData;\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attributes */\ntype tableHeaderAttributes = GlobalAttr & {\n  scope?: \"row\" | \"col\" | \"rowgroup\" | \"colgroup\";\n  abbr?: string;\n  colspan?: string;\n  headers?: string;\n  rowspan?: string;\n};\n\nexport const TableHeader = (\n  attributes: tableHeaderAttributes,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"th\", attributes, children);\n\nexport const Th = TableHeader;\n\n/* Caption for tables */\nexport const TableCaption = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"caption\", attributes, children);\n","/* TODO Strip all the unneccesary stuff out. And transform it into typescript\n *\n ******************FORKED FROM https://github.com/bigskysoftware/idiomorph *******************************************\n * BSD 2-Clause License\n *\n * Copyright (c) 2022, Big Sky Software\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nconst EMPTY_SET: Set<string> = new Set();\n\n// default configuration values, updatable by users now\nconst defaults = {\n  morphStyle: \"outerHTML\" as \"innerHTML\" | \"outerHTML\",\n  deadIds: new Set<string>(),\n  head: {\n    block: false as boolean,\n    ignore: false as boolean,\n    style: \"morph\" as \"morph\" | \"append\",\n    shouldPreserve: (elt: Element) => {\n      return elt.getAttribute(\"im-preserve\") === \"true\";\n    },\n    shouldReAppend: (elt: Element) => {\n      return elt.getAttribute(\"im-re-append\") === \"true\";\n    },\n  },\n} as const;\n\ntype contextType = typeof defaults & {\n  newContent: MorphEl;\n  ignoreActive: boolean;\n  ignoreActiveValue: boolean;\n  target: MorphEl | null;\n  config: contextType;\n  idMap: Map<MorphEl, Set<string>>;\n};\n\ntype MorphNode = Node & { generatedByIdiomorph?: boolean };\ntype MorphEl = Element & { generatedByIdiomorph?: boolean };\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function morph(\n  oldNode: MorphNode | MorphEl,\n  newContent: MorphNode | MorphEl | string | null,\n  config: Partial<contextType> = {},\n) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement;\n  }\n\n  if (typeof newContent === \"string\") {\n    newContent = parseContent(newContent) as MorphEl;\n  }\n\n  const normalizedContent = normalizeContent(newContent);\n\n  const ctx = createMorphContext(\n    oldNode as MorphEl,\n    normalizedContent as MorphEl,\n    config as contextType,\n  );\n\n  return morphNormalizedContent(\n    oldNode as any,\n    normalizedContent as MorphEl,\n    ctx,\n  );\n}\n\nfunction morphNormalizedContent(\n  oldNode: MorphEl,\n  normalizedNewContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector(\"head\");\n    const newHead = normalizedNewContent.querySelector(\"head\");\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx);\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(function () {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        );\n      });\n      return;\n    }\n  }\n\n  if (ctx.morphStyle === \"innerHTML\") {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx);\n    return oldNode.children;\n  } else {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling;\n    const nextSibling = bestMatch?.nextSibling;\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch as MorphEl, ctx);\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(\n        previousSibling as MorphEl,\n        morphedNode as MorphEl,\n        nextSibling as MorphEl,\n      );\n    } else {\n      // otherwise nothing was added to the DOM\n      return [];\n    }\n  }\n}\n\nfunction ignoreValueOfActiveElement(\n  possibleActiveElement: MorphEl,\n  ctx: contextType,\n) {\n  return (\n    ctx.ignoreActiveValue &&\n    possibleActiveElement === document.activeElement &&\n    possibleActiveElement !== document.body\n  );\n}\n\nfunction morphOldNodeTo(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    oldNode.remove();\n\n    return null;\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    oldNode.parentElement!.replaceChild(newContent, oldNode);\n\n    return newContent;\n  } else {\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== \"morph\"\n    ) {\n      handleHeadElement(newContent, oldNode, ctx);\n    } else {\n      syncNodeFrom(newContent, oldNode, ctx);\n      if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n        morphChildren(newContent, oldNode, ctx);\n      }\n    }\n    return oldNode;\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n */\nfunction morphChildren(\n  newParent: MorphEl,\n  oldParent: MorphEl,\n  ctx: contextType,\n) {\n  let nextNewChild = newParent.firstChild;\n  let insertionPoint = oldParent.firstChild;\n  let newChild;\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild;\n    nextNewChild = newChild.nextSibling;\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      oldParent.appendChild(newChild);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild as MorphEl, insertionPoint as MorphEl, ctx)) {\n      morphOldNodeTo(insertionPoint as MorphEl, newChild as MorphEl, ctx);\n      insertionPoint = insertionPoint.nextSibling;\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(\n      newParent,\n      oldParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n      morphOldNodeTo(idSetMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(\n      newParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n      morphOldNodeTo(softMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n\n    oldParent.insertBefore(newChild, insertionPoint);\n    removeIdsFromConsideration(ctx, newChild as MorphEl);\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint;\n    insertionPoint = insertionPoint.nextSibling;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\nfunction ignoreAttribute(\n  attr: string,\n  to: MorphEl,\n  updateType: \"update\" | \"remove\",\n  ctx: contextType,\n) {\n  if (\n    attr === \"value\" &&\n    ctx.ignoreActiveValue &&\n    to === document.activeElement\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction syncNodeFrom(from: MorphEl, to: MorphEl, ctx: contextType) {\n  const type = from.nodeType;\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const fromAttributes = from.attributes;\n    const toAttributes = to.attributes;\n    for (const fromAttribute of fromAttributes) {\n      if (ignoreAttribute(fromAttribute.name, to, \"update\", ctx)) {\n        continue;\n      }\n      if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value);\n      }\n    }\n    // iterate backwards to avoid skipping over items when a delete occurs\n    for (let i = toAttributes.length - 1; 0 <= i; i--) {\n      const toAttribute = toAttributes[i]!;\n      if (ignoreAttribute(toAttribute.name, to, \"remove\", ctx)) {\n        continue;\n      }\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name);\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue;\n    }\n  }\n\n  if (!ignoreValueOfActiveElement(to, ctx)) {\n    // sync input values\n    syncInputValue(from, to, ctx);\n  }\n}\n\nfunction syncBooleanAttribute(\n  from: MorphEl,\n  to: MorphEl,\n  attributeName: string,\n  ctx: contextType,\n) {\n  if ((from as any)[attributeName] !== (to as any)[attributeName]) {\n    const ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n    if (!ignoreUpdate) {\n      (to as any) = (from as any)[attributeName];\n    }\n    if ((from as any)[attributeName]) {\n      if (!ignoreUpdate) {\n        to.setAttribute(attributeName, (from as any)[attributeName]);\n      }\n    } else {\n      if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n        to.removeAttribute(attributeName);\n      }\n    }\n  }\n}\n\nfunction syncInputValue(from: MorphEl, to: MorphEl, ctx: contextType) {\n  if (\n    from instanceof HTMLInputElement &&\n    to instanceof HTMLInputElement &&\n    from.type !== \"file\"\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n\n    // sync boolean attributes\n    syncBooleanAttribute(from, to, \"checked\", ctx);\n    syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n    if (!from.hasAttribute(\"value\")) {\n      if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n        to.value = \"\";\n        to.removeAttribute(\"value\");\n      }\n    } else if (fromValue !== toValue) {\n      if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        to.setAttribute(\"value\", fromValue);\n        to.value = fromValue;\n      }\n    }\n  } else if (from instanceof HTMLOptionElement) {\n    syncBooleanAttribute(from, to, \"selected\", ctx);\n  } else if (\n    from instanceof HTMLTextAreaElement &&\n    to instanceof HTMLTextAreaElement\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n    if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n      return;\n    }\n    if (fromValue !== toValue) {\n      to.value = fromValue;\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue;\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n  newHeadTag: MorphEl,\n  currentHead: MorphEl,\n  ctx: contextType,\n) {\n  const removed = [];\n  const preserved = [];\n  const nodesToAppend = [];\n\n  const headMergeStyle = ctx.head.style;\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map();\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    const inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n    const isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n    const isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt);\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n        preserved.push(currentHeadElt);\n      }\n    } else {\n      if (headMergeStyle === \"append\") {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt);\n          nodesToAppend.push(currentHeadElt);\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n\n        removed.push(currentHeadElt);\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values());\n\n  for (const newNode of nodesToAppend) {\n    const newElt = document\n      .createRange()\n      .createContextualFragment(newNode.outerHTML).firstChild;\n  }\n\n  return [];\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\n\n/*\n      Deep merges the config object and the Idiomoroph.defaults object to\n      produce a final configuration object\n     */\nfunction mergeDefaults(config: Partial<contextType>) {\n  const finalConfig: Partial<contextType> = {};\n  // copy top level stuff into final config\n  Object.assign(finalConfig, defaults);\n  Object.assign(finalConfig, config);\n\n  // copy head config into final config  (do this to deep merge the head)\n  (finalConfig as any).head = {};\n  Object.assign(finalConfig.head as any, defaults.head);\n  Object.assign(finalConfig.head as any, config.head);\n  return finalConfig;\n}\n\nfunction createMorphContext(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  config: contextType,\n): contextType {\n  config = mergeDefaults(config) as any;\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    ignoreActiveValue: config.ignoreActiveValue,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    head: config.head,\n  };\n}\n\nfunction isIdSetMatch(\n  node1: null | MorphEl,\n  node2: MorphEl | null,\n  ctx: contextType,\n) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1.id !== \"\" && node1.id === node2.id) {\n      return true;\n    } else {\n      return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n  }\n  return false;\n}\n\nfunction isSoftMatch(node1: MorphEl | null, node2: MorphEl | null) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n  startInclusive: MorphNode | null,\n  endExclusive: MorphNode | null,\n  ctx: contextType,\n) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive;\n    startInclusive = startInclusive!.nextSibling!;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n  removeIdsFromConsideration(ctx, endExclusive as MorphEl);\n  return endExclusive!.nextSibling!;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n  newContent: MorphNode,\n  oldParent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(\n    ctx,\n    newChild,\n    oldParent as MorphEl,\n  );\n\n  const potentialMatch = null;\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    let potentialMatch = insertionPoint;\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0;\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch;\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(\n        ctx,\n        potentialMatch,\n        newContent as MorphEl,\n      );\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null;\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as MorphEl;\n    }\n  }\n  return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n  newContent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  let potentialSoftMatch = insertionPoint;\n  let nextSibling = newChild.nextSibling;\n  let siblingSoftMatchCount = 0;\n\n  while (potentialSoftMatch != null) {\n    if (\n      getIdIntersectionCount(ctx, potentialSoftMatch, newContent as MorphEl) > 0\n    ) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null;\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch;\n    }\n\n    if (isSoftMatch(nextSibling as MorphEl, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++;\n      nextSibling = nextSibling!.nextSibling;\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null;\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as null | MorphEl;\n  }\n\n  return potentialSoftMatch;\n}\n\nfunction parseContent(newContent: string) {\n  const parser = new DOMParser();\n\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    \"\",\n  );\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, \"text/html\");\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      (content as MorphNode).generatedByIdiomorph = true;\n      return content;\n    } else {\n      // otherwise return the html element as the parent container\n      const htmlElement: MorphNode | null = content.firstChild;\n      if (htmlElement) {\n        htmlElement.generatedByIdiomorph = true;\n        return htmlElement;\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(\n      \"<body><template>\" + newContent + \"</template></body>\",\n      \"text/html\",\n    );\n    const content = responseDoc.body.querySelector(\"template\")!.content;\n    (content as MorphNode).generatedByIdiomorph = true;\n    return content;\n  }\n}\n\nfunction normalizeContent(newContent: null | MorphEl | MorphNode) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement(\"div\");\n    return dummyParent;\n  } else if (newContent.generatedByIdiomorph) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent;\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement(\"div\");\n    dummyParent.append(newContent);\n    return dummyParent;\n  } else {\n    // all nodes in the array or HTMLElement collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement(\"div\");\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt);\n    }\n    return dummyParent;\n  }\n}\n\nfunction insertSiblings(\n  previousSibling: MorphEl | null,\n  morphedNode: MorphEl,\n  nextSibling: MorphEl | null,\n) {\n  const stack: MorphEl[] = [];\n  const added = [];\n  while (previousSibling != null) {\n    stack.push(previousSibling);\n    previousSibling = previousSibling.previousSibling as MorphEl | null;\n  }\n  while (stack.length > 0) {\n    const node = stack.pop();\n    added.push(node); // push added preceding siblings on in order and insert\n    morphedNode.parentElement!.insertBefore(node as MorphEl, morphedNode);\n  }\n  added.push(morphedNode);\n  while (nextSibling != null) {\n    stack.push(nextSibling);\n    added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as MorphEl;\n  }\n  while (stack.length > 0) {\n    morphedNode.parentElement!.insertBefore(\n      stack.pop() as MorphEl,\n      morphedNode.nextSibling,\n    );\n  }\n  return added;\n}\n\nfunction findBestNodeMatch(\n  newContent: MorphEl,\n  oldNode: MorphEl,\n  ctx: contextType,\n) {\n  let currentElement;\n  currentElement = newContent.firstChild;\n  let bestElement = currentElement;\n  let score = 0;\n  while (currentElement) {\n    const newScore = scoreElement(currentElement as MorphEl, oldNode, ctx);\n    if (newScore > score) {\n      bestElement = currentElement;\n      score = newScore;\n    }\n    currentElement = currentElement.nextSibling;\n  }\n  return bestElement;\n}\n\nfunction scoreElement(node1: MorphEl, node2: MorphEl, ctx: contextType) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n  }\n  return 0;\n}\n\nfunction removeNode(tempNode: MorphEl, ctx: contextType) {\n  removeIdsFromConsideration(ctx, tempNode);\n\n  tempNode.remove();\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: contextType, id: string) {\n  return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: contextType, id: string, targetNode: MorphEl) {\n  const idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n  return idSet.has(id);\n}\n\nfunction removeIdsFromConsideration(ctx: contextType, node: MorphEl) {\n  const idSet = ctx.idMap.get(node) || EMPTY_SET;\n  for (const id of idSet) {\n    // @ts-ignore\n    ctx.deadIds.add(id);\n  }\n}\n\nfunction getIdIntersectionCount(\n  ctx: contextType,\n  node1: MorphEl,\n  node2: MorphEl,\n) {\n  const sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n  let matchCount = 0;\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount;\n    }\n  }\n  return matchCount;\n}\n\nfunction populateIdMapForNode(node: MorphEl, idMap: Map<Node, Set<string>>) {\n  const nodeParent = node.parentElement;\n  // find all elements with an id property\n  const idElements = node.querySelectorAll(\"[id]\");\n  for (const elt of idElements) {\n    let current = elt;\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && current != null) {\n      let idSet = idMap.get(current);\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set();\n        idMap.set(current, idSet);\n      }\n      idSet.add(elt.id);\n      current = current.parentElement!;\n    }\n  }\n}\n\nfunction createIdMap(oldContent: MorphEl, newContent: MorphEl) {\n  const idMap: Map<MorphEl, Set<string>> = new Map();\n  populateIdMapForNode(oldContent, idMap);\n  populateIdMapForNode(newContent, idMap);\n  return idMap;\n}\n\n/// END OF MORPHING ////\n","import { morph } from \"./morphing\";\n\nexport type WhateverComponent = Comp<any>;\n\nclass Comp<K extends any> {\n  render: (data: K, comp: Comp<K>) => HTMLElement;\n  childComps: WhateverComponent[] = [];\n  protected parent: WhateverComponent;\n  public data: K;\n  protected changed = true;\n  public getParent() {\n    return this.parent;\n  }\n\n  /**\n   * Usefull when updating before the component needs to be rendered!\n   */\n  public UpdateNoRender(data: K) {\n    this.data = data;\n    this.changed = true;\n  }\n\n  public Update(newData: K) {\n    this.data = newData;\n    this.changed = true;\n    this.Render(true);\n  }\n\n  /** The current dom element*/\n  public currentRender: HTMLElement;\n\n  /** Get a (shallow) copy of the array of children */\n  public getChildren() {\n    return [...this.childComps];\n  }\n\n  /** Returns the child */\n  public addChild(c: WhateverComponent) {\n    //@ts-ignore\n    if (c == this) {\n      throw Error(\"Can't add yourself as a child!?\");\n    }\n    this.childComps.push(c);\n  }\n  public removeChild(c: WhateverComponent) {\n    this.childComps = this.childComps.filter((ch) => c != ch);\n  }\n\n  public Render(force = false) {\n    if (!(this.changed || force)) {\n      return this.currentRender;\n    }\n    const newR = this.render(this.data, this);\n    for (const c of this.childComps) {\n      c.Render(force);\n    }\n\n    morph(this.currentRender, newR, {});\n\n    this.changed = false;\n    return this.currentRender;\n  }\n\n  constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n  ) {\n    this.render = render;\n    this.data = data;\n    this.parent = parent;\n    this.currentRender = this.render(data, this);\n  }\n}\n\nlet rc: undefined | RootComp = undefined;\nexport function RootComponent() {\n  if (rc) return rc;\n  rc = new RootComp();\n  return rc;\n}\n\nclass RootComp extends Comp<undefined> {\n  constructor() {\n    super(undefined as any, undefined, () => {\n      // hacky method that works because the Root render does nothing and is equal the the previous render\n      return document.body;\n    });\n    this.parent = this as WhateverComponent;\n  }\n}\n\n/** A component can be used to Bind a Value to a Render */\nexport function Component<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n) {\n  const comp = new Comp(parent, data, render);\n\n  return comp;\n}\n\nexport type WhateverPageComponent = PageComp<any>;\n/**\n *\n * @param OnPageLoad Function is called when the route-path and matches the route this registered with in the 'pagehandler'. NOTE WHEN USING .Update ON COMPONENT IT WILL RENDER!!! (if you do so use no render)\n */\nexport class PageComp<K extends any> extends Comp<K> {\n  removeAllChildren() {\n    this.childComps = [];\n  }\n  onPageLoad: (data: K, comp: PageComp<K>) => void;\n\n  OnPageLoad() {\n    this.onPageLoad(this.data, this);\n  }\n\n  public constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n    onPageLoad: (data: K, comp: PageComp<K>) => void,\n  ) {\n    super(parent, data, render);\n    this.onPageLoad = onPageLoad;\n  }\n}\n\nexport function PageComponent<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n  onPageLoad: (data: K, comp: PageComp<K>) => void,\n) {\n  return new PageComp(parent, data, render, onPageLoad);\n}\n","import { type WhateverPageComponent } from \"../reactive/component\";\nimport { navigateTo } from \"./navigate\";\n\ntype routeItem = {\n  path: string;\n  route: RegExp;\n  comp: WhateverPageComponent;\n  params: paramItem[];\n};\n\ntype paramItem = {\n  pos: number;\n  name: string;\n  value?: string;\n};\n\nexport class PageRegister {\n  public Anchor: HTMLElement;\n  public routes: routeItem[];\n\n  public currentPage: WhateverPageComponent | undefined;\n  public currentRoute: routeItem | undefined;\n\n  public queryParams: URLSearchParams;\n  /**\n   * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n   * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n   */\n  public registerRoute(route: string, comp: WhateverPageComponent) {\n    const routesplit = route.split(\"/\");\n    let resultStr = \"\";\n\n    const params: paramItem[] = [];\n\n    const splitLen = routesplit.length;\n    if (splitLen == 0 || route == \"/\") {\n      resultStr = \"/\";\n    } else {\n      for (let i = 0; i < splitLen; i++) {\n        const s = routesplit[i];\n        if (!s || s.length == 0) {\n          continue;\n        }\n        if (s[0] == \"[\" && s[s.length - 1] == \"]\") {\n          const name = s.split(\"[\")[1]!.split(\"]\")[0];\n          const nparam = {\n            name: name!,\n            pos: i,\n          } satisfies paramItem;\n          params.push(nparam);\n          resultStr += `\\/[A-Za-z1-9_\\\\-]+`;\n\n          continue;\n        }\n        resultStr += \"/\" + s;\n      }\n    }\n    const routeI = {\n      comp: comp,\n      params: params,\n      path: route,\n      route: new RegExp(resultStr),\n    } satisfies routeItem;\n    if (this.routes.find((a) => a.route == routeI.route)) {\n      throw new Error(\n        `Route already exist '${route}'.\\nRegex: '${routeI.route.source}'\\nRouteData: ${JSON.stringify(routeI)}`,\n      );\n    }\n\n    this.routes.push(routeI);\n    return this;\n  }\n\n  public getParamValue(name: string) {\n    if (this.currentRoute) {\n      for (const p of this.currentRoute.params) {\n        if (p.name == name) {\n          return p.value;\n        }\n      }\n    }\n  }\n\n  public enable() {\n    // TODO not populate the window space (with this prefix it should really matter)\n    (window as any).__$HFX__Register = this;\n    window.addEventListener(\"popstate\", onPageChange);\n    onPageChange();\n    return this;\n  }\n\n  public constructor(anchor: HTMLElement) {\n    this.Anchor = anchor;\n    this.routes = [];\n    this.queryParams = new URLSearchParams(window.location.search);\n  }\n}\n\n/**\n * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n */\nexport function RouteRegister(el: HTMLElement) {\n  return new PageRegister(el);\n}\n\nfunction onPageChange() {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n\n  // reset the current values\n  reg.currentPage = undefined;\n\n  if (reg.currentRoute) {\n    reg.currentRoute.comp.removeAllChildren();\n    for (const p of reg.currentRoute.params) {\n      p.value = undefined;\n    }\n  }\n  reg.currentRoute = undefined;\n\n  reg.queryParams = new URLSearchParams(window.location.search);\n  let url = window.location.pathname;\n  // take care of trailing /\n  if (url.length > 1 && url.at(-1) == \"/\") {\n    url = url.slice(0, url.length - 1);\n  }\n  // load the current page\n  for (const r of reg.routes) {\n    const match = url.match(r.route);\n    reg.currentRoute = r;\n    if (match && match[0].length >= url.length) {\n      const splits = url.split(\"/\");\n      for (const p of r.params) {\n        p.value = splits[p.pos];\n      }\n      r.comp.OnPageLoad();\n      reg.Anchor.replaceChildren(r.comp.Render(true));\n      reg.currentPage = r.comp;\n      return;\n    }\n  }\n\n  // nothing found => 404 page\n  if (url.startsWith(\"/404\") || url.startsWith(\"404\")) {\n    return;\n  }\n  navigateTo(`/404?page=${url}`);\n}\n\n/** Get a param value from the current Route */\nexport function GetParamValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.getParamValue(name);\n  }\n  return undefined;\n}\n\n/** Get a query param (?name=value) value from the current url */\nexport function GetQueryValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.get(name);\n  }\n  return null;\n}\n\n/** Get an array[] with all query params that match the name (?name=value&name=otherValue) from the current url*/\nexport function GetQueryValues(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.getAll(name);\n  }\n  return [];\n}\n","/**\n * Fetch JSON\n */\nexport const fetcher = {\n  post,\n  get,\n};\n\ninterface FetchResult<T, K extends boolean> {\n  succes: K;\n  result: K extends true ? T : undefined;\n  /**\n   * Status will be 0 if err is caused by an exception\n   *\n   */\n  err: K extends false\n    ? { status: number; name: string; cause: string | object }\n    : undefined;\n}\n\n/**\n *\n * @param url\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function get<T>(\n  url: string,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"GET\";\n\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const fetch_result = await fetch(url, requestInit);\n\n    if (\n      fetch_result.ok &&\n      fetch_result.status >= 200 &&\n      fetch_result.status <= 299\n    ) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await fetch_result.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${fetch_result.status} => ${fetch_result.statusText}`,\n          cause: \"Request did not succees!\",\n          status: fetch_result.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n\n/**\n *\n * @param url\n * @param body\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {body} or {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function post<T>(\n  url: string,\n  body: string | null | undefined,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"POST\";\n  if (body) {\n    requestInit.body = body;\n  }\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const val = await fetch(url, requestInit);\n    if (val.ok && val.status >= 200 && val.status <= 299) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await val.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${val.status} => ${val.statusText}`,\n          cause: \"Request did not succees!\",\n          status: val.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n","type attributes = Record<string, string>;\nexport type HFXObject =\n  | {\n      tag: string;\n      attrs: attributes;\n      children: HFXObject[];\n    }\n  | string;\n\n/**\n * convert an Element to a HFXObject\n * this object can be turned into a JSON-string\n * and be turned into a Element again\n * (note: it stores the current state and not stuff like\n * listeners )\n */\nexport function elementToHFXObject(el: Element): HFXObject {\n  const tag = el.tagName;\n  const attrs: attributes = {};\n  const children: HFXObject[] = [];\n  const cNodes = el.childNodes;\n  const elAttrs = el.attributes;\n  for (const a of elAttrs) {\n    const aname = a.name;\n    const value = a.value;\n    (attrs as any)[aname] = value;\n  }\n\n  for (const c of cNodes) {\n    children.push(nodeToHFXObject(c));\n  }\n\n  return { tag: tag, attrs: attrs, children: children };\n}\n/**\n * @see elementToHFXObject\n *\n * Parse stuff from the dom to simple JS object\n * mainly for json parsing.\n */\nexport function nodeToHFXObject(node: Node) {\n  if (node instanceof Text) {\n    return (node as Text).textContent ?? \"\";\n  } else {\n    // we assert that this should work because\n    // we shouldn't really deal with strange fragments\n    // other other shenigans.\n    return elementToHFXObject(node as Element);\n  }\n}\n\nexport function HFXObjectToElement(hfx_object: HFXObject): Text | Element {\n  if (typeof hfx_object == \"string\") {\n    return document.createTextNode(hfx_object);\n  }\n  const el = document.createElement(hfx_object.tag);\n  for (const c of hfx_object.children) {\n    el.appendChild(HFXObjectToElement(c));\n  }\n  const akeys = Object.keys( hfx_object.attrs);\n  for (const a of akeys) {\n    el.setAttribute(a, hfx_object.attrs[a]!);\n  }\n\n  return el;\n}\n","import { Div, RenderToBody, t } from \"./elem/elem\";\nimport { H1, H2, H3, H4, H5, H6 } from \"./elem/headings\";\nimport { Img } from \"./elem/img\";\nimport { Input, Label } from \"./elem/input\";\nimport { Br, Hr } from \"./elem/style\";\nimport {\n  A,\n  Abbr,\n  B,\n  Bdi,\n  Bdo,\n  Cite,\n  I,\n  P,\n  Span,\n  Code,\n  BlockQuote,\n} from \"./elem/text\";\n\nimport { MetaDescription, Title, Base } from \"./elem/head\";\n\nimport {\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Tr,\n} from \"./elem/table\";\n\nimport {\n  Address,\n  Article,\n  Aside,\n  Button,\n  Footer,\n  Main,\n  Output,\n  Pre,\n  Nav,\n} from \"./elem/semantic\";\n\nimport { Component, PageComponent, RootComponent } from \"./reactive/component\";\n\nimport { navigateTo } from \"./pages/navigate\";\n\nimport {\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  RouteRegister,\n} from \"./pages/register\";\n\nimport { fetcher } from \"./fetcher\";\n\nimport {\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n} from \"./json_representation/hfx_object\";\nimport type { HFXObject } from \"./json_representation/hfx_object\";\n\n/* Extension methods */\n\nObject.defineProperty(HTMLElement.prototype, \"WithEvent$HFX\", {\n  value: function <T extends HTMLElement, K extends keyof HTMLElementEventMap>(\n    this: T,\n    eventtype: K,\n    listener: (ev: HTMLElementEventMap[K]) => void\n  ) {\n    this.addEventListener(eventtype, listener);\n    return this;\n  },\n});\n\nObject.defineProperty(Object.prototype, \"With$HFX\", {\n  value: function <T extends Object>(this: T, func: (obj: T) => void) {\n    func(this);\n    return this;\n  },\n});\n\ndeclare global {\n  interface HTMLElement {\n    /** Add an event listener and return the Element */\n    WithEvent$HFX<K extends keyof HTMLElementEventMap>(\n      eventtype: K,\n      listener: (ev: HTMLElementEventMap[K]) => void\n    ): this;\n  }\n  interface Object {\n    With$HFX<T extends Object>(this: T, run: (obj: T) => void): T;\n  }\n}\n\nexport {\n  /* HTML Tags */\n  A,\n  Abbr,\n  Address,\n  Article,\n  Aside,\n  B,\n  Base,\n  Bdi,\n  Bdo,\n  Br,\n  BlockQuote,\n  Button,\n  Cite,\n  Code,\n  /* Components */\n  Component,\n  Div,\n  /* fetcher */\n  fetcher,\n  Footer,\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n  H6,\n  Hr,\n  I,\n  Img,\n  Input,\n  Label,\n  Main,\n  MetaDescription,\n  Nav,\n  /* Routing */\n  navigateTo,\n  P,\n  PageComponent,\n  Pre,\n  Output,\n  /* Other DOM stuff */\n  RenderToBody,\n  RootComponent,\n  RouteRegister,\n  Span,\n  t,\n  /* Table stuff */\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Title,\n  Tr,\n  // json_representation\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n};\n\nexport type { HFXObject };\n","import { navigateTo } from \"../pages/navigate\";\nimport type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  addAttr,\n  addChildren,\n  createE,\n  t,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n  type TextChildren_Or_Undefined,\n} from \"./elem\";\n/**\n    * this file is for Elements with phrasing content that should have text as children\n    * Phrasing context:  https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#phrasing_content\n    But only the ones that are not just semantic divs\n    */\n\nexport function Span(\n  attributes: GlobalAttr,\n  childOrText: string | HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = document.createElement(\"span\");\n  addAttr(res, attributes);\n  if (typeof childOrText === \"string\") {\n    res.appendChild(t(childOrText));\n  } else {\n    addChildren(res, childOrText);\n  }\n  return res;\n}\n\nexport const P = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"p\", attributes, children);\n\nexport const Abbr = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(\"abbr\", attributes, children);\n\ntype anchorAttr = Partial<GlobalAttr> & {\n  href: string;\n  target?: targetValues;\n  download?: \"download\";\n  filename?: string;\n  hreflang?: string;\n  ping?: string;\n  referrerpolicy?:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  rel?: string;\n};\n\nexport function A(\n  attributes: anchorAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = createE(\"a\", attributes, children);\n  if (attributes.href[0] == \"/\") {\n    res.addEventListener(\"click\", (ev) => {\n      navigateTo((ev.target as HTMLAnchorElement).href);\n      ev.preventDefault();\n      return false;\n    });\n  }\n  return res;\n}\n\nexport const B = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"b\", attributes, children);\n\nexport const Bdi = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdi\", attributes, children);\n\nexport const Bdo = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdo\", attributes, children);\n\nexport const I = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"i\", attributes, children);\n\nexport const Cite = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"cite\", attributes, children);\n\nexport const Code = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"code\", attributes, children);\n\nexport const BlockQuote = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"blockquote\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\nexport const Address = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"address\", attributes, children);\n\nexport const Nav = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"nav\", attributes, children);\n\nexport const Pre = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"pre\", attributes, children);\n\nexport const Output = (\n  attributes: GlobalAttr & { for: string; name: string },\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"output\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article */\nexport const Article = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"article\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside */\nexport const Aside = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"aside\", attributes, children);\n\nexport const Main = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"main\", attributes, children);\n\nexport const Button = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"button\", attributes, children);\n\nexport const Footer = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"footer\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport { createS } from \"./elem\";\n\nexport const Br = (attributes: GlobalAttr) => createS(\"br\", attributes);\n\nexport const Hr = (attributes: GlobalAttr) => createS(\"hr\", attributes);\n","import type { GlobalAttr } from \"./attr\";\nimport { addAttr, createS } from \"./elem\";\n\ntype requiredImgAttr = { src: string };\ntype optionImgAttr = {\n  alt: string;\n  attributionsrc: string;\n  crossorigin: \"anonymous\" | \"use-credentials\";\n  decoding: \"sync\" | \"async\" | \"auto\";\n  elementtiming: string;\n  fetchpriority: \"high\" | \"low\" | \"auto\";\n  height: string;\n  width: string;\n  loading: \"eager\" | \"lazy\";\n  referrerpolicy:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  sizes: string;\n  srcset: string;\n};\n\ntype imageAttr = requiredImgAttr & GlobalAttr & Partial<optionImgAttr>;\n\nexport const Img = (attrs: imageAttr) => createS(\"img\", attrs);\n","import type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  createE,\n  createS,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\ntype inputRequired = {\n  type:\n    | \"button\"\n    | \"checkbox\"\n    | \"color\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"email\"\n    | \"file\"\n    | \"hidden\"\n    | \"image\"\n    | \"month\"\n    | \"password\"\n    | \"radio\"\n    | \"range\"\n    | \"reset\"\n    | \"search\"\n    | \"submit\"\n    | \"tel\"\n    | \"text\"\n    | \"time\"\n    | \"url\"\n    | \"week\";\n  /**   @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#name\n        '_charset_' combined with hidden will set the value to the 'user-agent'\n        'isindex' is not allowed as name\n         */\n  name: string | \"_charset_\";\n  id: string;\n};\n\nconst inputTypes = [\n  \"button\",\n  \"checkbox\",\n  \"color\",\n  \"date\",\n  \"datetime-local\",\n  \"email\",\n  \"file\",\n  \"hidden\",\n  \"image\",\n  \"month\",\n  \"password\",\n  \"radio\",\n  \"range\",\n  \"reset\",\n  \"search\",\n  \"submit\",\n  \"tel\",\n  \"text\",\n  \"time\",\n  \"url\",\n  \"week\",\n] as const;\ntype inputType = (typeof inputTypes)[number];\n\ntype SteppableAttr = { value: string; max: string; min: string; step: string };\ntype LengthAble = { value: string; maxlength: string; minlength: string };\ntype InputAttr<inputType> = {\n  id: string;\n  name: string;\n  /**  Tell the browser the input has a valid value before it can be submitted.\n    NOT VALID ON: hidden, range, color, and buttons.\n    @TODO might be fixed in later version  */\n  required?: \"required\";\n} & GlobalAttr &\n  (inputType extends \"button\"\n    ? { type: \"button\"; value: string }\n    : inputType extends \"checkbox\"\n      ? {\n          type: \"checkbox\";\n          value: string;\n          checked?: \"checked\";\n        }\n      : inputType extends \"color\"\n        ? { type: \"color\"; value?: string }\n        : inputType extends \"date\"\n          ? {\n              type: \"date\";\n            } & Partial<SteppableAttr>\n          : inputType extends \"datetime-local\"\n            ? {\n                type: \"datetime-local\";\n              } & Partial<SteppableAttr>\n            : inputType extends \"email\"\n              ? {\n                  type: \"email\";\n                  multiple?: \"multiple\";\n                  pattern?: string;\n                  placeholder?: string;\n                  readonly?: \"readonly\";\n                  size?: string;\n                  list?: string;\n                } & Partial<LengthAble>\n              : inputType extends \"file\"\n                ? {\n                    type: \"file\";\n                    value: \"\";\n                    accept?: \"string\";\n                    capture?: \"user\" | \"environment\";\n                    multiple?: \"multiple\";\n                    webkitdirectory?: \"webkitdirectory\";\n                  }\n                : inputType extends \"hidden\"\n                  ? {\n                      type: \"hidden\";\n                      // if the value is '_charset_' it will set the user-agent as value\n                      value: string | \"_charset_\";\n                    }\n                  : inputType extends \"image\"\n                    ? {\n                        type: \"image\";\n                        src?: string;\n                        alt?: string;\n                        formaction?: string;\n                        formenctype?:\n                          | \"application/x-www-form-urlencoded\"\n                          | \"multipart/form-data\"\n                          | \"text/plain\";\n                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                        formnovalidate?: \"formnovalidate\";\n                        formtarget?: targetValues;\n                      }\n                    : inputType extends \"month\"\n                      ? {\n                          type: \"month\";\n                          readonly?: \"readonly\";\n                          list?: string;\n                        } & Partial<SteppableAttr>\n                      : inputType extends \"nubmer\"\n                        ? {\n                            type: \"number\";\n                            list?: string;\n                            placeholder?: string;\n                            readonly?: \"readonly\";\n                          } & Partial<SteppableAttr>\n                        : inputType extends \"password\"\n                          ? {\n                              type: \"password\";\n                              pattern?: string;\n                              /* please use minlength and maxlength in CSS instead*/\n                              size?: string;\n                              readonly?: \"readonly\";\n                              placeholder?: string;\n                              autocomplete?:\n                                | \"on\"\n                                | \"off\"\n                                | \"current-password\"\n                                | \"new-password\";\n                            } & Partial<LengthAble>\n                          : inputType extends \"radio\"\n                            ? {\n                                type: \"radio\";\n                                checked?: \"checked\";\n                              }\n                            : inputType extends \"range\"\n                              ? {\n                                  type: \"range\";\n                                  list: string;\n                                  orient?: \"horizontal\" | \"vertical\";\n                                } & SteppableAttr\n                              : inputType extends \"reset\"\n                                ? {\n                                    type: \"reset\";\n                                  }\n                                : inputType extends \"search\"\n                                  ? {\n                                      type: \"search\";\n                                      value?: string;\n                                      list: string;\n                                      pattern: string;\n                                      placeholder: string;\n                                      readonly: \"readonly\";\n                                      size: string;\n                                      autocorrect?: \"on\" | \"off\";\n                                      incremental?: \"incremental\";\n                                      results?: string;\n                                    } & Partial<LengthAble>\n                                  : inputType extends \"submit\"\n                                    ? {\n                                        type: \"submit\";\n                                        value: string;\n                                        disabled?: \"disabled\";\n                                        formenctype?:\n                                          | \"application/x-www-form-urlencoded\"\n                                          | \"multipart/form-data\"\n                                          | \"text/plain\";\n                                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                                        formnovalidate?: \"formnovalidate\";\n                                        formtarget: targetValues;\n                                      }\n                                    : inputType extends \"tel\"\n                                      ? {\n                                          type: \"tel\";\n                                          list?: string;\n                                          readonly?: \"readonly\";\n                                          size?: string;\n                                          pattern?: string;\n                                        } & Partial<LengthAble>\n                                      : inputType extends \"text\"\n                                        ? {\n                                            type: \"text\";\n                                            list?: string;\n                                            pattern?: string;\n                                            readonly?: \"readonly\";\n                                            placeholder?: string;\n                                          } & Partial<LengthAble>\n                                        : inputType extends \"time\"\n                                          ? {\n                                              type: \"time\";\n                                              list?: string;\n                                              readonly: \"readonly\";\n                                            } & Partial<SteppableAttr>\n                                          : inputType extends \"url\"\n                                            ? {\n                                                type: \"url\";\n                                                list?: string;\n                                                pattern: string;\n                                                placeholder: string;\n                                                readonly?: \"readonly\";\n                                              } & Partial<LengthAble>\n                                            : inputType extends \"week\"\n                                              ? {\n                                                  type: \"week\";\n                                                  readonly?: \"readonly\";\n                                                } & Partial<SteppableAttr>\n                                              : {\n                                                  type: \"Error something went wrong ????\";\n                                                });\n\nexport const Input = (attrs: InputAttr<inputType>) => createS(\"input\", attrs);\n\ntype LabelAttr = GlobalAttr & { for: string };\n\nexport const Label = (\n  attrs: LabelAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"label\", attrs, children);\n\nexport const TextArea = (\n  attrs: GlobalAttr &\n    Partial<LengthAble> &\n    Partial<{ cols: number; rows: number; required: \"required\" }> &\n    Partial<{ name: string; id: string; value: string }>\n) => {\n  createS(\"textarea\", attrs);\n};\n"],"names":["t","document","createTextNode","createS","name","attributes","el","createElement","attrs","Object","keys","attr","setAttribute","createE","children","c","appendChild","Head","navigateTo","href","history","pushState","window","dispatchEvent","Event","TableHead","Thead","TableBody","Tbody","TableFoot","Tfoot","TableRow","Tr","TableData","Td","TableHeader","Th","EMPTY_SET","Set","defaults","morphStyle","deadIds","head","block","ignore","style","shouldPreserve","elt","getAttribute","shouldReAppend","morph","oldNode","newContent","config","Document","documentElement","parser","DOMParser","contentWithSvgsRemoved","replace","match","content","parseFromString","generatedByIdiomorph","htmlElement","firstChild","body","querySelector","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","ctx","finalConfig","assign","mergeDefaults","target","ignoreActive","ignoreActiveValue","idMap","createIdMap","createMorphContext","morphNormalizedContent","normalizedNewContent","oldHead","newHead","promises","handleHeadElement","Promise","all","then","morphChildren","bestMatch","currentElement","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","push","length","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","activeElement","remove","isSoftMatch","HTMLHeadElement","from","to","type","nodeType","fromAttributes","toAttributes","fromAttribute","ignoreAttribute","value","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","set","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","createRange","createContextualFragment","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","idIsWithinNode","targetNode","get","idSet","add","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","oldContent","Comp","getParent","this","parent","UpdateNoRender","data","changed","Update","newData","Render","getChildren","childComps","addChild","Error","removeChild","filter","ch","force","currentRender","newR","render","constructor","rc","RootComp","super","undefined","PageComp","removeAllChildren","OnPageLoad","onPageLoad","PageRegister","registerRoute","route","comp","routesplit","split","resultStr","params","splitLen","s","nparam","pos","routeI","path","RegExp","routes","find","a","source","JSON","stringify","getParamValue","currentRoute","p","enable","__$HFX__Register","addEventListener","onPageChange","anchor","Anchor","queryParams","URLSearchParams","location","search","reg","currentPage","url","pathname","at","slice","r","splits","replaceChildren","startsWith","fetcher","post","async","headers","requestInit","method","val","fetch","ok","status","succes","err","result","json","statusText","cause","e","res","fetch_result","elementToHFXObject","tag","cNodes","childNodes","elAttrs","aname","nodeToHFXObject","Text","textContent","defineProperty","HTMLElement","prototype","eventtype","listener","func","exports","A","ev","preventDefault","Abbr","Address","Article","Aside","B","Base","b","Bdi","Bdo","BlockQuote","Br","Button","Cite","Code","Component","Div","Footer","GetParamValue","GetQueryValue","GetQueryValues","getAll","H1","H2","H3","H4","H5","H6","HFXObjectToElement","hfx_object","akeys","Hr","I","Img","Input","Label","Main","MetaDescription","description","Nav","Output","P","PageComponent","Pre","RenderToBody","RootComponent","RouteRegister","Span","childOrText","addAttr","addChildren","Table","TableCaption","Title","title"],"mappings":"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"}