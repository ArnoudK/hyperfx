{"version":3,"file":"index.mjs","sources":["../src/elem/elem.ts","../src/elem/headings.ts","../src/elem/img.ts","../src/elem/input.ts","../src/elem/style.ts","../src/pages/navigate.ts","../src/elem/text.ts","../src/elem/head.ts","../src/elem/table.ts","../src/elem/semantic.ts","../src/reactive/morphing.ts","../src/reactive/component.ts","../src/pages/register.ts","../src/fetcher.ts","../src/json_representation/hfx_object.ts","../src/index.ts"],"sourcesContent":["import type { GlobalAttr, HtmlAtrribute } from \"./attr\";\n\nexport type HtmlElement_Or_Text_Children_Or_Undefined =\n  | readonly (Element | Text)[]\n  | undefined;\n\nexport type TextChildren_Or_Undefined = readonly Element[] | undefined;\n\nexport const Div = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"div\", attributes, children);\n\n/** Render text (the text content inside a tag): */\nexport function t(text: TemplateStringsArray | string, ...values: ((string[]))) {\n  let result = \"\";\n  if (typeof text === \"string\") {\n    // If the input is a string, just return it\n    result = text;\n  } else {\n    // Iterate through the static strings and interleave them with the values\n    for (let i = 0; i < values.length; i++) {\n      result += text[i]; // Append the static string part\n      result += String(values[i]); // Append the stringified value\n    }\n    // Append the last static string part\n    // (there's always one more string part than there are values)\n    result += text[values.length];\n  }\n  return document.createTextNode(result);\n}\nconst a = t`kek`\n\nexport const RenderToBody = (el: HTMLElement) => document.body.appendChild(el);\n\nexport const addAttr = (el: Element, attributes: object) => {\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n};\n\nexport const addChildren = (\n  e: Element,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => {\n  if (children)\n    for (const c of children) {\n      e.appendChild(c);\n    }\n};\n\nexport const createS = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  return el;\n};\n\nexport const createE = function <K extends keyof HTMLElementTagNameMap>(\n  name: K,\n  attributes: object,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const el = document.createElement(name);\n  const attrs = Object.keys(attributes);\n  for (const attr of attrs) {\n    el.setAttribute(attr, (attributes as any)[attr]);\n  }\n  if (children) {\n    for (const c of children) {\n      el.appendChild(c);\n    }\n  }\n  return el;\n};\n","import type { GlobalAttr } from \"./attr\";\nimport { createE } from \"./elem\";\n\ntype heads = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\";\n\nconst Head = (t: heads, attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(t, attributes, children);\n\nexport const H1 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h1\", attributes, children);\n\nexport const H2 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h2\", attributes, children);\n\nexport const H3 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h3\", attributes, children);\n\nexport const H4 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h4\", attributes, children);\n\nexport const H5 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h5\", attributes, children);\n\nexport const H6 = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  Head(\"h6\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport { addAttr, createS } from \"./elem\";\n\ntype requiredImgAttr = { src: string };\ntype optionImgAttr = {\n  alt: string;\n  attributionsrc: string;\n  crossorigin: \"anonymous\" | \"use-credentials\";\n  decoding: \"sync\" | \"async\" | \"auto\";\n  elementtiming: string;\n  fetchpriority: \"high\" | \"low\" | \"auto\";\n  height: string;\n  width: string;\n  loading: \"eager\" | \"lazy\";\n  referrerpolicy:\n    | \"no-referrer\"\n    | \"no-referrer-when-downgrade\"\n    | \"origin\"\n    | \"origin-when-cross-origin\"\n    | \"same-origin\"\n    | \"strict-origin\"\n    | \"strict-origin-when-cross-origin\"\n    | \"unsafe-url\";\n  sizes: string;\n  srcset: string;\n};\n\ntype imageAttr = requiredImgAttr & GlobalAttr & Partial<optionImgAttr>;\n\nexport const Img = (attrs: imageAttr) => createS(\"img\", attrs);\n","import type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  createE,\n  createS,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\ntype inputRequired = {\n  type:\n    | \"button\"\n    | \"checkbox\"\n    | \"color\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"email\"\n    | \"file\"\n    | \"hidden\"\n    | \"image\"\n    | \"month\"\n    | \"password\"\n    | \"radio\"\n    | \"range\"\n    | \"reset\"\n    | \"search\"\n    | \"submit\"\n    | \"tel\"\n    | \"text\"\n    | \"time\"\n    | \"url\"\n    | \"week\";\n  /**   @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#name\n        '_charset_' combined with hidden will set the value to the 'user-agent'\n        'isindex' is not allowed as name\n         */\n  name: string | \"_charset_\";\n  id: string;\n};\n\nconst inputTypes = [\n  \"button\",\n  \"checkbox\",\n  \"color\",\n  \"date\",\n  \"datetime-local\",\n  \"email\",\n  \"file\",\n  \"hidden\",\n  \"image\",\n  \"month\",\n  \"password\",\n  \"radio\",\n  \"range\",\n  \"reset\",\n  \"search\",\n  \"submit\",\n  \"tel\",\n  \"text\",\n  \"time\",\n  \"url\",\n  \"week\",\n] as const;\ntype inputType = (typeof inputTypes)[number];\n\ntype SteppableAttr = { value: string; max: string; min: string; step: string };\ntype LengthAble = { value: string; maxlength: string; minlength: string };\ntype InputAttr<inputType> = {\n  id: string;\n  name: string;\n  /**  Tell the browser the input has a valid value before it can be submitted.\n    NOT VALID ON: hidden, range, color, and buttons.\n    @TODO might be fixed in later version  */\n  required?: \"required\";\n} & GlobalAttr &\n  (inputType extends \"button\"\n    ? { type: \"button\"; value: string }\n    : inputType extends \"checkbox\"\n      ? {\n          type: \"checkbox\";\n          value: string;\n          checked?: \"checked\";\n        }\n      : inputType extends \"color\"\n        ? { type: \"color\"; value?: string }\n        : inputType extends \"date\"\n          ? {\n              type: \"date\";\n            } & Partial<SteppableAttr>\n          : inputType extends \"datetime-local\"\n            ? {\n                type: \"datetime-local\";\n              } & Partial<SteppableAttr>\n            : inputType extends \"email\"\n              ? {\n                  type: \"email\";\n                  multiple?: \"multiple\";\n                  pattern?: string;\n                  placeholder?: string;\n                  readonly?: \"readonly\";\n                  size?: string;\n                  list?: string;\n                } & Partial<LengthAble>\n              : inputType extends \"file\"\n                ? {\n                    type: \"file\";\n                    value: \"\";\n                    accept?: \"string\";\n                    capture?: \"user\" | \"environment\";\n                    multiple?: \"multiple\";\n                    webkitdirectory?: \"webkitdirectory\";\n                  }\n                : inputType extends \"hidden\"\n                  ? {\n                      type: \"hidden\";\n                      // if the value is '_charset_' it will set the user-agent as value\n                      value: string | \"_charset_\";\n                    }\n                  : inputType extends \"image\"\n                    ? {\n                        type: \"image\";\n                        src?: string;\n                        alt?: string;\n                        formaction?: string;\n                        formenctype?:\n                          | \"application/x-www-form-urlencoded\"\n                          | \"multipart/form-data\"\n                          | \"text/plain\";\n                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                        formnovalidate?: \"formnovalidate\";\n                        formtarget?: targetValues;\n                      }\n                    : inputType extends \"month\"\n                      ? {\n                          type: \"month\";\n                          readonly?: \"readonly\";\n                          list?: string;\n                        } & Partial<SteppableAttr>\n                      : inputType extends \"nubmer\"\n                        ? {\n                            type: \"number\";\n                            list?: string;\n                            placeholder?: string;\n                            readonly?: \"readonly\";\n                          } & Partial<SteppableAttr>\n                        : inputType extends \"password\"\n                          ? {\n                              type: \"password\";\n                              pattern?: string;\n                              /* please use minlength and maxlength in CSS instead*/\n                              size?: string;\n                              readonly?: \"readonly\";\n                              placeholder?: string;\n                              autocomplete?:\n                                | \"on\"\n                                | \"off\"\n                                | \"current-password\"\n                                | \"new-password\";\n                            } & Partial<LengthAble>\n                          : inputType extends \"radio\"\n                            ? {\n                                type: \"radio\";\n                                checked?: \"checked\";\n                              }\n                            : inputType extends \"range\"\n                              ? {\n                                  type: \"range\";\n                                  list: string;\n                                  orient?: \"horizontal\" | \"vertical\";\n                                } & SteppableAttr\n                              : inputType extends \"reset\"\n                                ? {\n                                    type: \"reset\";\n                                  }\n                                : inputType extends \"search\"\n                                  ? {\n                                      type: \"search\";\n                                      value?: string;\n                                      list: string;\n                                      pattern: string;\n                                      placeholder: string;\n                                      readonly: \"readonly\";\n                                      size: string;\n                                      autocorrect?: \"on\" | \"off\";\n                                      incremental?: \"incremental\";\n                                      results?: string;\n                                    } & Partial<LengthAble>\n                                  : inputType extends \"submit\"\n                                    ? {\n                                        type: \"submit\";\n                                        value: string;\n                                        disabled?: \"disabled\";\n                                        formenctype?:\n                                          | \"application/x-www-form-urlencoded\"\n                                          | \"multipart/form-data\"\n                                          | \"text/plain\";\n                                        formmethod?: \"get\" | \"post\" | \"dialog\";\n                                        formnovalidate?: \"formnovalidate\";\n                                        formtarget: targetValues;\n                                      }\n                                    : inputType extends \"tel\"\n                                      ? {\n                                          type: \"tel\";\n                                          list?: string;\n                                          readonly?: \"readonly\";\n                                          size?: string;\n                                          pattern?: string;\n                                        } & Partial<LengthAble>\n                                      : inputType extends \"text\"\n                                        ? {\n                                            type: \"text\";\n                                            list?: string;\n                                            pattern?: string;\n                                            readonly?: \"readonly\";\n                                            placeholder?: string;\n                                          } & Partial<LengthAble>\n                                        : inputType extends \"time\"\n                                          ? {\n                                              type: \"time\";\n                                              list?: string;\n                                              readonly: \"readonly\";\n                                            } & Partial<SteppableAttr>\n                                          : inputType extends \"url\"\n                                            ? {\n                                                type: \"url\";\n                                                list?: string;\n                                                pattern: string;\n                                                placeholder: string;\n                                                readonly?: \"readonly\";\n                                              } & Partial<LengthAble>\n                                            : inputType extends \"week\"\n                                              ? {\n                                                  type: \"week\";\n                                                  readonly?: \"readonly\";\n                                                } & Partial<SteppableAttr>\n                                              : {\n                                                  type: \"Error something went wrong ????\";\n                                                });\n\nexport const Input = (attrs: InputAttr<inputType>) => createS(\"input\", attrs);\n\ntype LabelAttr = GlobalAttr & { for: string };\n\nexport const Label = (\n  attrs: LabelAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"label\", attrs, children);\n\nexport const TextArea = (\n  attrs: GlobalAttr &\n    Partial<LengthAble> &\n    Partial<{ cols: number; rows: number; required: \"required\" }> &\n    Partial<{ name: string; id: string; value: string }>\n) => {\n  createS(\"textarea\", attrs);\n};\n","import type { GlobalAttr } from \"./attr\";\nimport { createS } from \"./elem\";\n\nexport const Br = (attributes: GlobalAttr) => createS(\"br\", attributes);\n\nexport const Hr = (attributes: GlobalAttr) => createS(\"hr\", attributes);\n","/**\n * Navigate to a url by pushing it and popstate this allows for soft navigation using HyperFX\n * The URL must be registered in the PageRegister!!!\n */\nexport function navigateTo(href: string) {\n  history.pushState({}, \"\", href);\n  window.dispatchEvent(new Event(\"popstate\"));\n}\n","import { navigateTo } from \"../pages/navigate\";\nimport type { GlobalAttr, targetValues } from \"./attr\";\nimport {\n  addAttr,\n  addChildren,\n  createE,\n  t,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n  type TextChildren_Or_Undefined,\n} from \"./elem\";\n/**\n    * this file is for Elements with phrasing content that should have text as children\n    * Phrasing context:  https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories#phrasing_content\n    But only the ones that are not just semantic divs\n    */\n\nexport function Span(\n  attributes: GlobalAttr,\n  childOrText: string | HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = document.createElement(\"span\");\n  addAttr(res, attributes);\n  if (typeof childOrText === \"string\") {\n    res.appendChild(t(childOrText));\n  } else {\n    addChildren(res, childOrText);\n  }\n  return res;\n}\n\n\n\n\nexport const P = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"p\", attributes, children);\n\nexport const Abbr = (attributes: GlobalAttr, children?: readonly Text[]) =>\n  createE(\"abbr\", attributes, children);\n\ntype anchorAttr = Partial<GlobalAttr> & {\n  href: string;\n  target?: targetValues;\n  download?: \"download\";\n  filename?: string;\n  hreflang?: string;\n  ping?: string;\n  referrerpolicy?:\n  | \"no-referrer\"\n  | \"no-referrer-when-downgrade\"\n  | \"origin\"\n  | \"origin-when-cross-origin\"\n  | \"same-origin\"\n  | \"strict-origin\"\n  | \"strict-origin-when-cross-origin\"\n  | \"unsafe-url\";\n  rel?: string;\n};\n\nexport function A(\n  attributes: anchorAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) {\n  const res = createE(\"a\", attributes, children);\n  if (attributes.href[0] == \"/\") {\n    res.addEventListener(\"click\", (ev) => {\n      navigateTo((ev.target as HTMLAnchorElement).href);\n      ev.preventDefault();\n      return false;\n    });\n  }\n  return res;\n}\n\nexport const B = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"b\", attributes, children);\n\nexport const Bdi = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdi\", attributes, children);\n\nexport const Bdo = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"bdo\", attributes, children);\n\nexport const I = (\n  attributes: GlobalAttr,\n  children?: TextChildren_Or_Undefined\n) => createE(\"i\", attributes, children);\n\nexport const Cite = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"cite\", attributes, children);\n\nexport const Code = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"code\", attributes, children);\n\nexport const BlockQuote = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"blockquote\", attributes, children);\n","/* Elements that should be inside the head */\n\nimport type { targetValues } from \"./attr\";\nimport { createS } from \"./elem\";\n\ntype BaseAttrOpt = {\n  href: string;\n  target: targetValues;\n};\n\ntype BaseAttr = Partial<BaseAttrOpt> &\n  (Pick<BaseAttrOpt, \"href\"> | Pick<BaseAttrOpt, \"target\">);\n/**\n * Must be inside <head>\n * If used there should only be 1 inside the document\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base\n * The <base> HTML element specifies the base URL to use for all relative URLs in a document. There can be only one <base> element in a document.\n *\n *A document's used base URL can be accessed by scripts with Node.baseURI. If the document has no <base> elements, then baseURI defaults to location.href.\n */\nexport function Base(attr: BaseAttr) {\n  const b = document.createElement(\"base\");\n  if (attr.href) b.setAttribute(\"href\", attr.href);\n  if (attr.target) b.setAttribute(\"target\", attr.target);\n  return b;\n}\n/**\n * Sets or updates the meta description in the head\n */\nexport function MetaDescription(description: string) {\n  const current = document.head.querySelector('meta[name=\"description\"]');\n  if (current) {\n    current.setAttribute(\"content\", description);\n  } else {\n    document.head.appendChild(\n      createS(\"meta\", { name: \"description\", content: description })\n    );\n  }\n}\n\n/**\n * Sets or updates the document title (this is a void function use it above the return in your render)\n */\nexport const Title = (title: string) => (document.title = title);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\n/** <caption> <thead> <tbody> <tfooter>\n * also accepts <tr> directly\n * But it seems like using a <tbody> is preffered by the new standards\n */\ntype tableChild =\n  | HTMLTableSectionElement\n  | HTMLTableCaptionElement\n  | HTMLTableRowElement;\n\nexport const Table = (\n  attributes: GlobalAttr,\n  children?: readonly tableChild[]\n) => createE(\"table\", attributes, children);\n\nexport const TableHead = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"thead\", attributes, children);\n\nexport const Thead = TableHead;\n\nexport const TableBody = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tbody\", attributes, children);\n\nexport const Tbody = TableBody;\n\nexport const TableFoot = (\n  attributes: GlobalAttr,\n  children?: readonly HTMLTableRowElement[]\n) => createE(\"tfoot\", attributes, children);\n\nexport const Tfoot = TableFoot;\n\n/** Only <td> and <th> */\ntype tableRowChild = HTMLTableCellElement;\n\nexport const TableRow = (\n  attributes: GlobalAttr,\n  children?: readonly tableRowChild[]\n) => createE(\"tr\", attributes, children);\n\nexport const Tr = TableRow;\n\nexport const TableData = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"td\", attributes, children);\n\nexport const Td = TableData;\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attributes */\ntype tableHeaderAttributes = GlobalAttr & {\n  scope?: \"row\" | \"col\" | \"rowgroup\" | \"colgroup\";\n  abbr?: string;\n  colspan?: string;\n  headers?: string;\n  rowspan?: string;\n};\n\nexport const TableHeader = (\n  attributes: tableHeaderAttributes,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"th\", attributes, children);\n\nexport const Th = TableHeader;\n\n/* Caption for tables */\nexport const TableCaption = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"caption\", attributes, children);\n","import type { GlobalAttr } from \"./attr\";\nimport {\n  createE,\n  type HtmlElement_Or_Text_Children_Or_Undefined,\n} from \"./elem\";\n\nexport const Address = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"address\", attributes, children);\n\nexport const Nav = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"nav\", attributes, children);\n\nexport const Pre = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"pre\", attributes, children);\n\nexport const Output = (\n  attributes: GlobalAttr & { for: string; name: string },\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"output\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article */\nexport const Article = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"article\", attributes, children);\n\n/** https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside */\nexport const Aside = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"aside\", attributes, children);\n\nexport const Main = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"main\", attributes, children);\n\nexport const Button = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"button\", attributes, children);\n\nexport const Footer = (\n  attributes: GlobalAttr,\n  children?: HtmlElement_Or_Text_Children_Or_Undefined\n) => createE(\"footer\", attributes, children);\n","/* TODO Strip all the unneccesary stuff out. And transform it into typescript\n *\n ******************FORKED FROM https://github.com/bigskysoftware/idiomorph *******************************************\n * BSD 2-Clause License\n *\n * Copyright (c) 2022, Big Sky Software\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nconst EMPTY_SET: Set<string> = new Set();\n\n// default configuration values, updatable by users now\nconst defaults = {\n  morphStyle: \"outerHTML\" as \"innerHTML\" | \"outerHTML\",\n  deadIds: new Set<string>(),\n  head: {\n    block: false as boolean,\n    ignore: false as boolean,\n    style: \"morph\" as \"morph\" | \"append\",\n    shouldPreserve: (elt: Element) => {\n      return elt.getAttribute(\"im-preserve\") === \"true\";\n    },\n    shouldReAppend: (elt: Element) => {\n      return elt.getAttribute(\"im-re-append\") === \"true\";\n    },\n  },\n} as const;\n\ntype contextType = typeof defaults & {\n  newContent: MorphEl;\n  ignoreActive: boolean;\n  ignoreActiveValue: boolean;\n  target: MorphEl | null;\n  config: contextType;\n  idMap: Map<MorphEl, Set<string>>;\n};\n\ntype MorphNode = Node & { generatedByIdiomorph?: boolean };\ntype MorphEl = Element & { generatedByIdiomorph?: boolean };\n\n//=============================================================================\n// Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n//=============================================================================\nexport function morph(\n  oldNode: MorphNode | MorphEl,\n  newContent: MorphNode | MorphEl | string | null,\n  config: Partial<contextType> = {},\n) {\n  if (oldNode instanceof Document) {\n    oldNode = oldNode.documentElement;\n  }\n\n  if (typeof newContent === \"string\") {\n    newContent = parseContent(newContent) as MorphEl;\n  }\n\n  const normalizedContent = normalizeContent(newContent);\n\n  const ctx = createMorphContext(\n    oldNode as MorphEl,\n    normalizedContent as MorphEl,\n    config as contextType,\n  );\n\n  return morphNormalizedContent(\n    oldNode as any,\n    normalizedContent as MorphEl,\n    ctx,\n  );\n}\n\nfunction morphNormalizedContent(\n  oldNode: MorphEl,\n  normalizedNewContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.head.block) {\n    const oldHead = oldNode.querySelector(\"head\");\n    const newHead = normalizedNewContent.querySelector(\"head\");\n    if (oldHead && newHead) {\n      const promises = handleHeadElement(newHead, oldHead, ctx);\n      // when head promises resolve, call morph again, ignoring the head tag\n      Promise.all(promises).then(function () {\n        morphNormalizedContent(\n          oldNode,\n          normalizedNewContent,\n          Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          }),\n        );\n      });\n      return;\n    }\n  }\n\n  if (ctx.morphStyle === \"innerHTML\") {\n    // innerHTML, so we are only updating the children\n    morphChildren(normalizedNewContent, oldNode, ctx);\n    return oldNode.children;\n  } else {\n    // otherwise find the best element match in the new content, morph that, and merge its siblings\n    // into either side of the best match\n    const bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n    // stash the siblings that will need to be inserted on either side of the best match\n    const previousSibling = bestMatch?.previousSibling;\n    const nextSibling = bestMatch?.nextSibling;\n\n    // morph it\n    const morphedNode = morphOldNodeTo(oldNode, bestMatch as MorphEl, ctx);\n\n    if (bestMatch) {\n      // if there was a best match, merge the siblings in too and return the\n      // whole bunch\n      return insertSiblings(\n        previousSibling as MorphEl,\n        morphedNode as MorphEl,\n        nextSibling as MorphEl,\n      );\n    } else {\n      // otherwise nothing was added to the DOM\n      return [];\n    }\n  }\n}\n\nfunction ignoreValueOfActiveElement(\n  possibleActiveElement: MorphEl,\n  ctx: contextType,\n) {\n  return (\n    ctx.ignoreActiveValue &&\n    possibleActiveElement === document.activeElement &&\n    possibleActiveElement !== document.body\n  );\n}\n\nfunction morphOldNodeTo(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  ctx: contextType,\n) {\n  if (ctx.ignoreActive && oldNode === document.activeElement) {\n    // don't morph focused element\n  } else if (newContent == null) {\n    oldNode.remove();\n\n    return null;\n  } else if (!isSoftMatch(oldNode, newContent)) {\n    oldNode.parentElement!.replaceChild(newContent, oldNode);\n\n    return newContent;\n  } else {\n    if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n      // ignore the head element\n    } else if (\n      oldNode instanceof HTMLHeadElement &&\n      ctx.head.style !== \"morph\"\n    ) {\n      handleHeadElement(newContent, oldNode, ctx);\n    } else {\n      syncNodeFrom(newContent, oldNode, ctx);\n      if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n        morphChildren(newContent, oldNode, ctx);\n      }\n    }\n    return oldNode;\n  }\n}\n\n/**\n * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n * by using id sets, we are able to better match up with content deeper in the DOM.\n *\n * Basic algorithm is, for each node in the new content:\n *\n * - if we have reached the end of the old parent, append the new content\n * - if the new content has an id set match with the current insertion point, morph\n * - search for an id set match\n * - if id set match found, morph\n * - otherwise search for a \"soft\" match\n * - if a soft match is found, morph\n * - otherwise, prepend the new node before the current insertion point\n *\n * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n *\n */\nfunction morphChildren(\n  newParent: MorphEl,\n  oldParent: MorphEl,\n  ctx: contextType,\n) {\n  let nextNewChild = newParent.firstChild;\n  let insertionPoint = oldParent.firstChild;\n  let newChild;\n\n  // run through all the new content\n  while (nextNewChild) {\n    newChild = nextNewChild;\n    nextNewChild = newChild.nextSibling;\n\n    // if we are at the end of the exiting parent's children, just append\n    if (insertionPoint == null) {\n      oldParent.appendChild(newChild);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // if the current node has an id set match then morph\n    if (isIdSetMatch(newChild as MorphEl, insertionPoint as MorphEl, ctx)) {\n      morphOldNodeTo(insertionPoint as MorphEl, newChild as MorphEl, ctx);\n      insertionPoint = insertionPoint.nextSibling;\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // otherwise search forward in the existing old children for an id set match\n    let idSetMatch = findIdSetMatch(\n      newParent,\n      oldParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a potential match, remove the nodes until that point and morph\n    if (idSetMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n      morphOldNodeTo(idSetMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // no id set match found, so scan forward for a soft match for the current node\n    let softMatch = findSoftMatch(\n      newParent,\n      newChild as MorphEl,\n      insertionPoint as MorphEl,\n      ctx,\n    );\n\n    // if we found a soft match for the current node, morph\n    if (softMatch) {\n      insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n      morphOldNodeTo(softMatch, newChild as MorphEl, ctx);\n      removeIdsFromConsideration(ctx, newChild as MorphEl);\n      continue;\n    }\n\n    // abandon all hope of morphing, just insert the new child before the insertion point\n    // and move on\n\n    oldParent.insertBefore(newChild, insertionPoint);\n    removeIdsFromConsideration(ctx, newChild as MorphEl);\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint !== null) {\n    let tempNode = insertionPoint;\n    insertionPoint = insertionPoint.nextSibling;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n}\n\n//=============================================================================\n// Attribute Syncing Code\n//=============================================================================\n\nfunction ignoreAttribute(\n  attr: string,\n  to: MorphEl,\n  updateType: \"update\" | \"remove\",\n  ctx: contextType,\n) {\n  if (\n    attr === \"value\" &&\n    ctx.ignoreActiveValue &&\n    to === document.activeElement\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction syncNodeFrom(from: MorphEl, to: MorphEl, ctx: contextType) {\n  const type = from.nodeType;\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const fromAttributes = from.attributes;\n    const toAttributes = to.attributes;\n    for (const fromAttribute of fromAttributes) {\n      if (ignoreAttribute(fromAttribute.name, to, \"update\", ctx)) {\n        continue;\n      }\n      if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n        to.setAttribute(fromAttribute.name, fromAttribute.value);\n      }\n    }\n    // iterate backwards to avoid skipping over items when a delete occurs\n    for (let i = toAttributes.length - 1; 0 <= i; i--) {\n      const toAttribute = toAttributes[i]!;\n      if (ignoreAttribute(toAttribute.name, to, \"remove\", ctx)) {\n        continue;\n      }\n      if (!from.hasAttribute(toAttribute.name)) {\n        to.removeAttribute(toAttribute.name);\n      }\n    }\n  }\n\n  // sync text nodes\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (to.nodeValue !== from.nodeValue) {\n      to.nodeValue = from.nodeValue;\n    }\n  }\n\n  if (!ignoreValueOfActiveElement(to, ctx)) {\n    // sync input values\n    syncInputValue(from, to, ctx);\n  }\n}\n\nfunction syncBooleanAttribute(\n  from: MorphEl,\n  to: MorphEl,\n  attributeName: string,\n  ctx: contextType,\n) {\n  if ((from as any)[attributeName] !== (to as any)[attributeName]) {\n    const ignoreUpdate = ignoreAttribute(attributeName, to, \"update\", ctx);\n    if (!ignoreUpdate) {\n      (to as any) = (from as any)[attributeName];\n    }\n    if ((from as any)[attributeName]) {\n      if (!ignoreUpdate) {\n        to.setAttribute(attributeName, (from as any)[attributeName]);\n      }\n    } else {\n      if (!ignoreAttribute(attributeName, to, \"remove\", ctx)) {\n        to.removeAttribute(attributeName);\n      }\n    }\n  }\n}\n\nfunction syncInputValue(from: MorphEl, to: MorphEl, ctx: contextType) {\n  if (\n    from instanceof HTMLInputElement &&\n    to instanceof HTMLInputElement &&\n    from.type !== \"file\"\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n\n    // sync boolean attributes\n    syncBooleanAttribute(from, to, \"checked\", ctx);\n    syncBooleanAttribute(from, to, \"disabled\", ctx);\n\n    if (!from.hasAttribute(\"value\")) {\n      if (!ignoreAttribute(\"value\", to, \"remove\", ctx)) {\n        to.value = \"\";\n        to.removeAttribute(\"value\");\n      }\n    } else if (fromValue !== toValue) {\n      if (!ignoreAttribute(\"value\", to, \"update\", ctx)) {\n        to.setAttribute(\"value\", fromValue);\n        to.value = fromValue;\n      }\n    }\n  } else if (from instanceof HTMLOptionElement) {\n    syncBooleanAttribute(from, to, \"selected\", ctx);\n  } else if (\n    from instanceof HTMLTextAreaElement &&\n    to instanceof HTMLTextAreaElement\n  ) {\n    const fromValue = from.value;\n    const toValue = to.value;\n    if (ignoreAttribute(\"value\", to, \"update\", ctx)) {\n      return;\n    }\n    if (fromValue !== toValue) {\n      to.value = fromValue;\n    }\n    if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n      to.firstChild.nodeValue = fromValue;\n    }\n  }\n}\n\n//=============================================================================\n// the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n//=============================================================================\nfunction handleHeadElement(\n  newHeadTag: MorphEl,\n  currentHead: MorphEl,\n  ctx: contextType,\n) {\n  const removed = [];\n  const preserved = [];\n  const nodesToAppend = [];\n\n  const headMergeStyle = ctx.head.style;\n\n  // put all new head elements into a Map, by their outerHTML\n  const srcToNewHeadNodes = new Map();\n  for (const newHeadChild of newHeadTag.children) {\n    srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n  }\n\n  // for each elt in the current head\n  for (const currentHeadElt of currentHead.children) {\n    // If the current head element is in the map\n    const inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n    const isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n    const isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n    if (inNewContent || isPreserved) {\n      if (isReAppended) {\n        // remove the current version and let the new version replace it and re-execute\n        removed.push(currentHeadElt);\n      } else {\n        // this element already exists and should not be re-appended, so remove it from\n        // the new content map, preserving it in the DOM\n        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n        preserved.push(currentHeadElt);\n      }\n    } else {\n      if (headMergeStyle === \"append\") {\n        // we are appending and this existing element is not new content\n        // so if and only if it is marked for re-append do we do anything\n        if (isReAppended) {\n          removed.push(currentHeadElt);\n          nodesToAppend.push(currentHeadElt);\n        }\n      } else {\n        // if this is a merge, we remove this content since it is not in the new head\n\n        removed.push(currentHeadElt);\n      }\n    }\n  }\n\n  // Push the remaining new head elements in the Map into the\n  // nodes to append to the head tag\n  nodesToAppend.push(...srcToNewHeadNodes.values());\n\n  for (const newNode of nodesToAppend) {\n    const newElt = document\n      .createRange()\n      .createContextualFragment(newNode.outerHTML).firstChild;\n  }\n\n  return [];\n}\n\n//=============================================================================\n// Misc\n//=============================================================================\n\n/*\n      Deep merges the config object and the Idiomoroph.defaults object to\n      produce a final configuration object\n     */\nfunction mergeDefaults(config: Partial<contextType>) {\n  const finalConfig: Partial<contextType> = {};\n  // copy top level stuff into final config\n  Object.assign(finalConfig, defaults);\n  Object.assign(finalConfig, config);\n\n  // copy head config into final config  (do this to deep merge the head)\n  (finalConfig as any).head = {};\n  Object.assign(finalConfig.head as any, defaults.head);\n  Object.assign(finalConfig.head as any, config.head);\n  return finalConfig;\n}\n\nfunction createMorphContext(\n  oldNode: MorphEl,\n  newContent: MorphEl,\n  config: contextType,\n): contextType {\n  config = mergeDefaults(config) as any;\n  return {\n    target: oldNode,\n    newContent: newContent,\n    config: config,\n    morphStyle: config.morphStyle,\n    ignoreActive: config.ignoreActive,\n    ignoreActiveValue: config.ignoreActiveValue,\n    idMap: createIdMap(oldNode, newContent),\n    deadIds: new Set(),\n    head: config.head,\n  };\n}\n\nfunction isIdSetMatch(\n  node1: null | MorphEl,\n  node2: MorphEl | null,\n  ctx: contextType,\n) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n    if (node1.id !== \"\" && node1.id === node2.id) {\n      return true;\n    } else {\n      return getIdIntersectionCount(ctx, node1, node2) > 0;\n    }\n  }\n  return false;\n}\n\nfunction isSoftMatch(node1: MorphEl | null, node2: MorphEl | null) {\n  if (node1 == null || node2 == null) {\n    return false;\n  }\n  return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n}\n\nfunction removeNodesBetween(\n  startInclusive: MorphNode | null,\n  endExclusive: MorphNode | null,\n  ctx: contextType,\n) {\n  while (startInclusive !== endExclusive) {\n    const tempNode = startInclusive;\n    startInclusive = startInclusive!.nextSibling!;\n    removeNode(tempNode as MorphEl, ctx);\n  }\n  removeIdsFromConsideration(ctx, endExclusive as MorphEl);\n  return endExclusive!.nextSibling!;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential id match\n// for the newChild.  We stop if we find a potential id match for the new child OR\n// if the number of potential id matches we are discarding is greater than the\n// potential id matches for the new child\n//=============================================================================\nfunction findIdSetMatch(\n  newContent: MorphNode,\n  oldParent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  // max id matches we are willing to discard in our search\n  const newChildPotentialIdCount = getIdIntersectionCount(\n    ctx,\n    newChild,\n    oldParent as MorphEl,\n  );\n\n  const potentialMatch = null;\n\n  // only search forward if there is a possibility of an id match\n  if (newChildPotentialIdCount > 0) {\n    let potentialMatch = insertionPoint;\n    // if there is a possibility of an id match, scan forward\n    // keep track of the potential id match count we are discarding (the\n    // newChildPotentialIdCount must be greater than this to make it likely\n    // worth it)\n    let otherMatchCount = 0;\n    while (potentialMatch != null) {\n      // If we have an id match, return the current potential match\n      if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n        return potentialMatch;\n      }\n\n      // computer the other potential matches of this new content\n      otherMatchCount += getIdIntersectionCount(\n        ctx,\n        potentialMatch,\n        newContent as MorphEl,\n      );\n      if (otherMatchCount > newChildPotentialIdCount) {\n        // if we have more potential id matches in _other_ content, we\n        // do not have a good candidate for an id match, so return null\n        return null;\n      }\n\n      // advanced to the next old content child\n      potentialMatch = potentialMatch.nextSibling as MorphEl;\n    }\n  }\n  return potentialMatch;\n}\n\n//=============================================================================\n// Scans forward from the insertionPoint in the old parent looking for a potential soft match\n// for the newChild.  We stop if we find a potential soft match for the new child OR\n// if we find a potential id match in the old parents children OR if we find two\n// potential soft matches for the next two pieces of new content\n//=============================================================================\nfunction findSoftMatch(\n  newContent: MorphNode,\n  newChild: MorphEl,\n  insertionPoint: MorphEl | null,\n  ctx: contextType,\n) {\n  let potentialSoftMatch = insertionPoint;\n  let nextSibling = newChild.nextSibling;\n  let siblingSoftMatchCount = 0;\n\n  while (potentialSoftMatch != null) {\n    if (\n      getIdIntersectionCount(ctx, potentialSoftMatch, newContent as MorphEl) > 0\n    ) {\n      // the current potential soft match has a potential id set match with the remaining new\n      // content so bail out of looking\n      return null;\n    }\n\n    // if we have a soft match with the current node, return it\n    if (isSoftMatch(newChild, potentialSoftMatch)) {\n      return potentialSoftMatch;\n    }\n\n    if (isSoftMatch(nextSibling as MorphEl, potentialSoftMatch)) {\n      // the next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++;\n      nextSibling = nextSibling!.nextSibling;\n\n      // If there are two future soft matches, bail to allow the siblings to soft match\n      // so that we don't consume future soft matches for the sake of the current node\n      if (siblingSoftMatchCount >= 2) {\n        return null;\n      }\n    }\n\n    // advanced to the next old content child\n    potentialSoftMatch = potentialSoftMatch.nextSibling as null | MorphEl;\n  }\n\n  return potentialSoftMatch;\n}\n\nfunction parseContent(newContent: string) {\n  const parser = new DOMParser();\n\n  // remove svgs to avoid false-positive matches on head, etc.\n  const contentWithSvgsRemoved = newContent.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    \"\",\n  );\n\n  // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n  if (\n    contentWithSvgsRemoved.match(/<\\/html>/) ||\n    contentWithSvgsRemoved.match(/<\\/head>/) ||\n    contentWithSvgsRemoved.match(/<\\/body>/)\n  ) {\n    const content = parser.parseFromString(newContent, \"text/html\");\n    // if it is a full HTML document, return the document itself as the parent container\n    if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n      (content as MorphNode).generatedByIdiomorph = true;\n      return content;\n    } else {\n      // otherwise return the html element as the parent container\n      const htmlElement: MorphNode | null = content.firstChild;\n      if (htmlElement) {\n        htmlElement.generatedByIdiomorph = true;\n        return htmlElement;\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n    // deal with touchy tags like tr, tbody, etc.\n    const responseDoc = parser.parseFromString(\n      \"<body><template>\" + newContent + \"</template></body>\",\n      \"text/html\",\n    );\n    const content = responseDoc.body.querySelector(\"template\")!.content;\n    (content as MorphNode).generatedByIdiomorph = true;\n    return content;\n  }\n}\n\nfunction normalizeContent(newContent: null | MorphEl | MorphNode) {\n  if (newContent == null) {\n    // noinspection UnnecessaryLocalVariableJS\n    const dummyParent = document.createElement(\"div\");\n    return dummyParent;\n  } else if (newContent.generatedByIdiomorph) {\n    // the template tag created by idiomorph parsing can serve as a dummy parent\n    return newContent;\n  } else if (newContent instanceof Node) {\n    // a single node is added as a child to a dummy parent\n    const dummyParent = document.createElement(\"div\");\n    dummyParent.append(newContent);\n    return dummyParent;\n  } else {\n    // all nodes in the array or HTMLElement collection are consolidated under\n    // a single dummy parent element\n    const dummyParent = document.createElement(\"div\");\n    for (const elt of [...newContent]) {\n      dummyParent.append(elt);\n    }\n    return dummyParent;\n  }\n}\n\nfunction insertSiblings(\n  previousSibling: MorphEl | null,\n  morphedNode: MorphEl,\n  nextSibling: MorphEl | null,\n) {\n  const stack: MorphEl[] = [];\n  const added = [];\n  while (previousSibling != null) {\n    stack.push(previousSibling);\n    previousSibling = previousSibling.previousSibling as MorphEl | null;\n  }\n  while (stack.length > 0) {\n    const node = stack.pop();\n    added.push(node); // push added preceding siblings on in order and insert\n    morphedNode.parentElement!.insertBefore(node as MorphEl, morphedNode);\n  }\n  added.push(morphedNode);\n  while (nextSibling != null) {\n    stack.push(nextSibling);\n    added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n    nextSibling = nextSibling.nextSibling as MorphEl;\n  }\n  while (stack.length > 0) {\n    morphedNode.parentElement!.insertBefore(\n      stack.pop() as MorphEl,\n      morphedNode.nextSibling,\n    );\n  }\n  return added;\n}\n\nfunction findBestNodeMatch(\n  newContent: MorphEl,\n  oldNode: MorphEl,\n  ctx: contextType,\n) {\n  let currentElement;\n  currentElement = newContent.firstChild;\n  let bestElement = currentElement;\n  let score = 0;\n  while (currentElement) {\n    const newScore = scoreElement(currentElement as MorphEl, oldNode, ctx);\n    if (newScore > score) {\n      bestElement = currentElement;\n      score = newScore;\n    }\n    currentElement = currentElement.nextSibling;\n  }\n  return bestElement;\n}\n\nfunction scoreElement(node1: MorphEl, node2: MorphEl, ctx: contextType) {\n  if (isSoftMatch(node1, node2)) {\n    return 0.5 + getIdIntersectionCount(ctx, node1, node2);\n  }\n  return 0;\n}\n\nfunction removeNode(tempNode: MorphEl, ctx: contextType) {\n  removeIdsFromConsideration(ctx, tempNode);\n\n  tempNode.remove();\n}\n\n//=============================================================================\n// ID Set Functions\n//=============================================================================\n\nfunction isIdInConsideration(ctx: contextType, id: string) {\n  return !ctx.deadIds.has(id);\n}\n\nfunction idIsWithinNode(ctx: contextType, id: string, targetNode: MorphEl) {\n  const idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n  return idSet.has(id);\n}\n\nfunction removeIdsFromConsideration(ctx: contextType, node: MorphEl) {\n  const idSet = ctx.idMap.get(node) || EMPTY_SET;\n  for (const id of idSet) {\n    // @ts-ignore\n    ctx.deadIds.add(id);\n  }\n}\n\nfunction getIdIntersectionCount(\n  ctx: contextType,\n  node1: MorphEl,\n  node2: MorphEl,\n) {\n  const sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n  let matchCount = 0;\n  for (const id of sourceSet) {\n    // a potential match is an id in the source and potentialIdsSet, but\n    // that has not already been merged into the DOM\n    if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n      ++matchCount;\n    }\n  }\n  return matchCount;\n}\n\nfunction populateIdMapForNode(node: MorphEl, idMap: Map<Node, Set<string>>) {\n  const nodeParent = node.parentElement;\n  // find all elements with an id property\n  const idElements = node.querySelectorAll(\"[id]\");\n  for (const elt of idElements) {\n    let current = elt;\n    // walk up the parent hierarchy of that element, adding the id\n    // of element to the parent's id set\n    while (current !== nodeParent && current != null) {\n      let idSet = idMap.get(current);\n      // if the id set doesn't exist, create it and insert it in the  map\n      if (idSet == null) {\n        idSet = new Set();\n        idMap.set(current, idSet);\n      }\n      idSet.add(elt.id);\n      current = current.parentElement!;\n    }\n  }\n}\n\nfunction createIdMap(oldContent: MorphEl, newContent: MorphEl) {\n  const idMap: Map<MorphEl, Set<string>> = new Map();\n  populateIdMapForNode(oldContent, idMap);\n  populateIdMapForNode(newContent, idMap);\n  return idMap;\n}\n\n/// END OF MORPHING ////\n","import { morph } from \"./morphing\";\n\nexport type WhateverComponent = Comp<any>;\n\nclass Comp<K extends any> {\n  render: (data: K, comp: Comp<K>) => HTMLElement;\n  childComps: WhateverComponent[] = [];\n  protected parent: WhateverComponent;\n  public data: K;\n  protected changed = true;\n  public getParent() {\n    return this.parent;\n  }\n\n  /**\n   * Usefull when updating before the component needs to be rendered!\n   */\n  public UpdateNoRender(data: K) {\n    this.data = data;\n    this.changed = true;\n  }\n\n  public Update(newData: K) {\n    this.data = newData;\n    this.changed = true;\n    this.Render(true);\n  }\n\n  /** The current dom element*/\n  public currentRender: HTMLElement;\n\n  /** Get a (shallow) copy of the array of children */\n  public getChildren() {\n    return [...this.childComps];\n  }\n\n  /** Returns the child */\n  public addChild(c: WhateverComponent) {\n    //@ts-ignore\n    if (c == this) {\n      throw Error(\"Can't add yourself as a child!?\");\n    }\n    this.childComps.push(c);\n  }\n  public removeChild(c: WhateverComponent) {\n    this.childComps = this.childComps.filter((ch) => c != ch);\n  }\n\n  public Render(force = false) {\n    if (!(this.changed || force)) {\n      return this.currentRender;\n    }\n    const newR = this.render(this.data, this);\n    for (const c of this.childComps) {\n      c.Render(force);\n    }\n\n    morph(this.currentRender, newR, {});\n\n    this.changed = false;\n    return this.currentRender;\n  }\n\n  constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n  ) {\n    this.render = render;\n    this.data = data;\n    this.parent = parent;\n    this.currentRender = this.render(data, this);\n  }\n}\n\nlet rc: undefined | RootComp = undefined;\nexport function RootComponent() {\n  if (rc) return rc;\n  rc = new RootComp();\n  return rc;\n}\n\nclass RootComp extends Comp<undefined> {\n  constructor() {\n    super(undefined as any, undefined, () => {\n      // hacky method that works because the Root render does nothing and is equal the the previous render\n      return document.body;\n    });\n    this.parent = this as WhateverComponent;\n  }\n}\n\n/** A component can be used to Bind a Value to a Render */\nexport function Component<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n) {\n  const comp = new Comp(parent, data, render);\n\n  return comp;\n}\n\nexport type WhateverPageComponent = PageComp<any>;\n/**\n *\n * @param OnPageLoad Function is called when the route-path and matches the route this registered with in the 'pagehandler'. NOTE WHEN USING .Update ON COMPONENT IT WILL RENDER!!! (if you do so use no render)\n */\nexport class PageComp<K extends any> extends Comp<K> {\n  removeAllChildren() {\n    this.childComps = [];\n  }\n  onPageLoad: (data: K, comp: PageComp<K>) => void;\n\n  OnPageLoad() {\n    this.onPageLoad(this.data, this);\n  }\n\n  public constructor(\n    parent: WhateverComponent,\n    data: K,\n    render: (data: K, comp: Comp<K>) => HTMLElement,\n    onPageLoad: (data: K, comp: PageComp<K>) => void,\n  ) {\n    super(parent, data, render);\n    this.onPageLoad = onPageLoad;\n  }\n}\n\nexport function PageComponent<K extends any>(\n  parent: WhateverComponent,\n  data: K,\n  render: (data: K, comp: Comp<K>) => HTMLElement,\n  onPageLoad: (data: K, comp: PageComp<K>) => void,\n) {\n  return new PageComp(parent, data, render, onPageLoad);\n}\n","import { type WhateverPageComponent } from \"../reactive/component\";\nimport { navigateTo } from \"./navigate\";\n\ntype routeItem = {\n  path: string;\n  route: RegExp;\n  comp: WhateverPageComponent;\n  params: paramItem[];\n};\n\ntype paramItem = {\n  pos: number;\n  name: string;\n  value?: string;\n};\n\nexport class PageRegister {\n  public Anchor: HTMLElement;\n  public routes: routeItem[];\n\n  public currentPage: WhateverPageComponent | undefined;\n  public currentRoute: routeItem | undefined;\n\n  public queryParams: URLSearchParams;\n  /**\n   * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n   * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n   */\n  public registerRoute(route: string, comp: WhateverPageComponent) {\n    const routesplit = route.split(\"/\");\n    let resultStr = \"\";\n\n    const params: paramItem[] = [];\n\n    const splitLen = routesplit.length;\n    if (splitLen == 0 || route == \"/\") {\n      resultStr = \"/\";\n    } else {\n      for (let i = 0; i < splitLen; i++) {\n        const s = routesplit[i];\n        if (!s || s.length == 0) {\n          continue;\n        }\n        if (s[0] == \"[\" && s[s.length - 1] == \"]\") {\n          const name = s.split(\"[\")[1]!.split(\"]\")[0];\n          const nparam = {\n            name: name!,\n            pos: i,\n          } satisfies paramItem;\n          params.push(nparam);\n          resultStr += `\\/[A-Za-z1-9_\\\\-]+`;\n\n          continue;\n        }\n        resultStr += \"/\" + s;\n      }\n    }\n    const routeI = {\n      comp: comp,\n      params: params,\n      path: route,\n      route: new RegExp(resultStr),\n    } satisfies routeItem;\n    if (this.routes.find((a) => a.route == routeI.route)) {\n      throw new Error(\n        `Route already exist '${route}'.\\nRegex: '${routeI.route.source}'\\nRouteData: ${JSON.stringify(routeI)}`,\n      );\n    }\n\n    this.routes.push(routeI);\n    return this;\n  }\n\n  public getParamValue(name: string) {\n    if (this.currentRoute) {\n      for (const p of this.currentRoute.params) {\n        if (p.name == name) {\n          return p.value;\n        }\n      }\n    }\n  }\n\n  public enable() {\n    // TODO not populate the window space (with this prefix it should really matter)\n    (window as any).__$HFX__Register = this;\n    window.addEventListener(\"popstate\", onPageChange);\n    onPageChange();\n    return this;\n  }\n\n  public constructor(anchor: HTMLElement) {\n    this.Anchor = anchor;\n    this.routes = [];\n    this.queryParams = new URLSearchParams(window.location.search);\n  }\n}\n\n/**\n * Add a route with a custom component. Those will be loaded on page load or a softnavigate with navigateTo.\n * params can be added with [name] e.g.: '/mypage/[myparam]/info'\n */\nexport function RouteRegister(el: HTMLElement) {\n  return new PageRegister(el);\n}\n\nfunction onPageChange() {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n\n  // reset the current values\n  reg.currentPage = undefined;\n\n  if (reg.currentRoute) {\n    reg.currentRoute.comp.removeAllChildren();\n    for (const p of reg.currentRoute.params) {\n      p.value = undefined;\n    }\n  }\n  reg.currentRoute = undefined;\n\n  reg.queryParams = new URLSearchParams(window.location.search);\n  let url = window.location.pathname;\n  // take care of trailing /\n  if (url.length > 1 && url.at(-1) == \"/\") {\n    url = url.slice(0, url.length - 1);\n  }\n  // load the current page\n  for (const r of reg.routes) {\n    const match = url.match(r.route);\n    reg.currentRoute = r;\n    if (match && match[0].length >= url.length) {\n      const splits = url.split(\"/\");\n      for (const p of r.params) {\n        p.value = splits[p.pos];\n      }\n      r.comp.OnPageLoad();\n      reg.Anchor.replaceChildren(r.comp.Render(true));\n      reg.currentPage = r.comp;\n      return;\n    }\n  }\n\n  // nothing found => 404 page\n  if (url.startsWith(\"/404\") || url.startsWith(\"404\")) {\n    return;\n  }\n  navigateTo(`/404?page=${url}`);\n}\n\n/** Get a param value from the current Route */\nexport function GetParamValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.getParamValue(name);\n  }\n  return undefined;\n}\n\n/** Get a query param (?name=value) value from the current url */\nexport function GetQueryValue(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.get(name);\n  }\n  return null;\n}\n\n/** Get an array[] with all query params that match the name (?name=value&name=otherValue) from the current url*/\nexport function GetQueryValues(name: string) {\n  const reg: PageRegister = (window as any).__$HFX__Register;\n  if (reg) {\n    return reg.queryParams.getAll(name);\n  }\n  return [];\n}\n","/**\n * Fetch JSON\n */\nexport const fetcher = {\n  post,\n  get,\n};\n\ninterface FetchResult<T, K extends boolean> {\n  succes: K;\n  result: K extends true ? T : undefined;\n  /**\n   * Status will be 0 if err is caused by an exception\n   *\n   */\n  err: K extends false\n    ? { status: number; name: string; cause: string | object }\n    : undefined;\n}\n\n/**\n *\n * @param url\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function get<T>(\n  url: string,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"GET\";\n\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const fetch_result = await fetch(url, requestInit);\n\n    if (\n      fetch_result.ok &&\n      fetch_result.status >= 200 &&\n      fetch_result.status <= 299\n    ) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await fetch_result.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${fetch_result.status} => ${fetch_result.statusText}`,\n          cause: \"Request did not succees!\",\n          status: fetch_result.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n\n/**\n *\n * @param url\n * @param body\n * @param headers\n * @param requestInit modify all the request init params. {method} will always be post. If {body} or {headers} is specified it will override the {requestInit})\n * @returns {result} is successful otherwise {{error}}\n */\nasync function post<T>(\n  url: string,\n  body: string | null | undefined,\n  headers: {} | undefined | undefined,\n  requestInit: Partial<RequestInit> | null | undefined\n): Promise<FetchResult<T, boolean>> {\n  if (!requestInit) requestInit = {};\n\n  requestInit.method = \"POST\";\n  if (body) {\n    requestInit.body = body;\n  }\n  if (headers) {\n    requestInit.headers = headers;\n  }\n  try {\n    const val = await fetch(url, requestInit);\n    if (val.ok && val.status >= 200 && val.status <= 299) {\n      return {\n        succes: true,\n        err: undefined,\n        result: await val.json(),\n      };\n    } else {\n      return {\n        succes: false,\n        result: undefined,\n        err: {\n          name: `Status: ${val.status} => ${val.statusText}`,\n          cause: \"Request did not succees!\",\n          status: val.status,\n        },\n      };\n    }\n  } catch (e: any) {\n    const res = {\n      err: e,\n      succes: false,\n      result: undefined,\n    };\n    res.err.status = 0;\n    return res;\n  }\n}\n","type attributes = Record<string, string>;\nexport type HFXObject =\n  | {\n      tag: string;\n      attrs: attributes;\n      children: HFXObject[];\n    }\n  | string;\n\n/**\n * convert an Element to a HFXObject\n * this object can be turned into a JSON-string\n * and be turned into a Element again\n * (note: it stores the current state and not stuff like\n * listeners )\n */\nexport function elementToHFXObject(el: Element): HFXObject {\n  const tag = el.tagName;\n  const attrs: attributes = {};\n  const children: HFXObject[] = [];\n  const cNodes = el.childNodes;\n  const elAttrs = el.attributes;\n  for (const a of elAttrs) {\n    const aname = a.name;\n    const value = a.value;\n    (attrs as any)[aname] = value;\n  }\n\n  for (const c of cNodes) {\n    children.push(nodeToHFXObject(c));\n  }\n\n  return { tag: tag, attrs: attrs, children: children };\n}\n/**\n * @see elementToHFXObject\n *\n * Parse stuff from the dom to simple JS object\n * mainly for json parsing.\n */\nexport function nodeToHFXObject(node: Node) {\n  if (node instanceof Text) {\n    return (node as Text).textContent ?? \"\";\n  } else {\n    // we assert that this should work because\n    // we shouldn't really deal with strange fragments\n    // other other shenigans.\n    return elementToHFXObject(node as Element);\n  }\n}\n\nexport function HFXObjectToElement(hfx_object: HFXObject): Text | Element {\n  if (typeof hfx_object == \"string\") {\n    return document.createTextNode(hfx_object);\n  }\n  const el = document.createElement(hfx_object.tag);\n  for (const c of hfx_object.children) {\n    el.appendChild(HFXObjectToElement(c));\n  }\n  const akeys = Object.keys( hfx_object.attrs);\n  for (const a of akeys) {\n    el.setAttribute(a, hfx_object.attrs[a]!);\n  }\n\n  return el;\n}\n","import { Div, RenderToBody, t } from \"./elem/elem\";\nimport { H1, H2, H3, H4, H5, H6 } from \"./elem/headings\";\nimport { Img } from \"./elem/img\";\nimport { Input, Label } from \"./elem/input\";\nimport { Br, Hr } from \"./elem/style\";\nimport {\n  A,\n  Abbr,\n  B,\n  Bdi,\n  Bdo,\n  Cite,\n  I,\n  P,\n  Span,\n  Code,\n  BlockQuote,\n} from \"./elem/text\";\n\nimport { MetaDescription, Title, Base } from \"./elem/head\";\n\nimport {\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Tr,\n} from \"./elem/table\";\n\nimport {\n  Address,\n  Article,\n  Aside,\n  Button,\n  Footer,\n  Main,\n  Output,\n  Pre,\n  Nav,\n} from \"./elem/semantic\";\n\nimport { Component, PageComponent, RootComponent } from \"./reactive/component\";\n\nimport { navigateTo } from \"./pages/navigate\";\n\nimport {\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  RouteRegister,\n} from \"./pages/register\";\n\nimport { fetcher } from \"./fetcher\";\n\nimport {\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n} from \"./json_representation/hfx_object\";\nimport type { HFXObject } from \"./json_representation/hfx_object\";\n\n/* Extension methods */\n\nObject.defineProperty(HTMLElement.prototype, \"WithEvent$HFX\", {\n  value: function <T extends HTMLElement, K extends keyof HTMLElementEventMap>(\n    this: T,\n    eventtype: K,\n    listener: (ev: HTMLElementEventMap[K]) => void\n  ) {\n    this.addEventListener(eventtype, listener);\n    return this;\n  },\n});\n\nObject.defineProperty(Object.prototype, \"With$HFX\", {\n  value: function <T extends Object>(this: T, func: (obj: T) => void) {\n    func(this);\n    return this;\n  },\n});\n\ndeclare global {\n  interface HTMLElement {\n    /** Add an event listener and return the Element */\n    WithEvent$HFX<K extends keyof HTMLElementEventMap>(\n      eventtype: K,\n      listener: (ev: HTMLElementEventMap[K]) => void\n    ): this;\n  }\n  interface Object {\n    With$HFX<T extends Object>(this: T, run: (obj: T) => void): T;\n  }\n}\n\nexport {\n  /* HTML Tags */\n  A,\n  Abbr,\n  Address,\n  Article,\n  Aside,\n  B,\n  Base,\n  Bdi,\n  Bdo,\n  Br,\n  BlockQuote,\n  Button,\n  Cite,\n  Code,\n  /* Components */\n  Component,\n  Div,\n  /* fetcher */\n  fetcher,\n  Footer,\n  GetParamValue,\n  GetQueryValue,\n  GetQueryValues,\n  H1,\n  H2,\n  H3,\n  H4,\n  H5,\n  H6,\n  Hr,\n  I,\n  Img,\n  Input,\n  Label,\n  Main,\n  MetaDescription,\n  Nav,\n  /* Routing */\n  navigateTo,\n  P,\n  PageComponent,\n  Pre,\n  Output,\n  /* Other DOM stuff */\n  RenderToBody,\n  RootComponent,\n  RouteRegister,\n  Span,\n  t,\n  /* Table stuff */\n  Table,\n  TableBody,\n  TableCaption,\n  TableData,\n  TableFoot,\n  TableHead,\n  TableHeader,\n  TableRow,\n  Tbody,\n  Td,\n  Tfoot,\n  Th,\n  Thead,\n  Title,\n  Tr,\n  // json_representation\n  elementToHFXObject,\n  nodeToHFXObject,\n  HFXObjectToElement,\n};\n\nexport type { HFXObject };\n"],"names":[],"mappings":"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"}